@import 'lib/const.js';

json2Layer.init = function ( doc ) {
	this.doc = doc;
}

var onRun = function ( context ) {
	log( 'Start Proccessing ------------------------------------------' );
	json2Layer.init( context.document );
	var doc = json2Layer.doc;
	var currentPage = doc.currentPage();

	var openPanel = NSOpenPanel.openPanel();
	    openPanel.setTitle( "Choose a JSON File" );
	    openPanel.setCanCreateDirectories = false;
	    openPanel.setCanChooseFiles = true;

	var fileTypes = ['json'];
	var openPanelButtonPressed = openPanel.runModalForDirectory_file_types_( nil, nil, fileTypes );

	if ( openPanelButtonPressed == NSFileHandlingPanelOKButton ) {
		var filePath = openPanel.URL().path();
		var fwJSON = JSON.parse( NSString.stringWithContentsOfFile( filePath ) ); 
		log( 'Open File from: ' + filePath );
		json2Layer.orgSymbols = fwJSON.symbols;
		json2Layer.resPath.basePath    = openPanel.directoryURL().path();
		json2Layer.resPath.exportedDir = fwJSON.resExportedDir;
	} else {
		return false;
	}

	if ( 7 <= json2Layer.appVer.minor ) {
		log( '-> Create Symbol Master' );
		var masterPage = doc.addBlankPage();
		doc.pages().objectAtIndex( 1 ).setName( 'Symbols' );
		json2Layer.symbols = {};
		for ( var symbolID in fwJSON.symbols ) {
			json2Layer.symbolMaster.create( masterPage, fwJSON.symbols[symbolID], symbolID );
		}
		doc.setCurrentPage( doc.pages().objectAtIndex(0) );
		log( '-> // Create Symbol Master' );
	} else {
		json2Layer.symbols = [];
	}

	var artboardPageOffset = 0; 
	var artboardStateOffset = 0; 
	for ( var i = 0; i < fwJSON.pages.length; i++ ) {
		log( 'Page: ' + fwJSON.pages[i].pageName + ' //////////////////////////////////////////' );
		for ( var stateIndex = 0; stateIndex < fwJSON.pages[i].frames.length; stateIndex++ ) {
			log( 'Frame (state): ' + stateIndex + ' ------------------------------------------>' );
			var artboard = MSArtboardGroup.new();
			artboard.setName( unescape( fwJSON.pages[i].pageName ));
			artboard.frame().setX( artboardPageOffset );
			artboard.frame().setY( artboardStateOffset );
			artboard.frame().setWidth( fwJSON.pages[i].width );
			artboard.frame().setHeight( fwJSON.pages[i].height );
			artboardStateOffset = artboardStateOffset + fwJSON.pages[i].height + 100;
			// currentPage.addLayer( artboard );
			currentPage.addLayers( NSArray.arrayWithObjects( artboard ) );
			var artboards = doc.currentPage().artboards();

			setGrid( artboard, fwJSON.documentSetting.grid );
			addGuideline( artboard, fwJSON.pages[i].guides, fwJSON.documentSetting.grid.gridOrigin );
			fwJSON.pages[i].frames[stateIndex].topLayers.reverse();
			createElements( artboard, fwJSON.pages[i].frames[stateIndex].topLayers );
			// log( fwJSON.pages[i].width );
		};
		artboardPageOffset += fwJSON.pages[i].width + 100;
		artboardStateOffset = 0;
	}

	log( '------------------------------------------ Close Proccessing' );

}

json2Layer.symbolMaster = ( function () {
	var artboardZeroPoint = { x: 0, y: 0 };

	return {
		create: function( parent, symbol, symbolID ) {
			if ( !json2Layer.symbols[symbolID] ) {
				log( '-> Create Symbol Master: ' + symbol.symbolName );
				var artboard = MSArtboardGroup.new();
				artboard.setName( unescape( symbol.symbolName ) );
				artboard.frame().setX( artboardZeroPoint.x );
				artboard.frame().setY( artboardZeroPoint.y );
				artboard.frame().setWidth( symbol.width );
				artboard.frame().setHeight( symbol.height );
				artboardZeroPoint.x += symbol.width + 100;
				parent.addLayers( [artboard] );

				createElements( artboard, symbol.elements );

				for (var i = artboard.layers().count() - 1; i >= 0; i--) {
					artboard.layers().objectAtIndex( i ).frame().addX( -symbol.left );
					artboard.layers().objectAtIndex( i ).frame().addY( -symbol.top );
				}
				json2Layer.symbols[symbolID] = artboard.convertToSymbol();
				log( '   // Created symbol master: ' + symbol.symbolName );
			}
		}
	};

})();

function createElements( parent, elems, isMask ) {
	log( '-> Child Layer Proccessing' );
	if ( !isMask ) isMask = false;

	for ( var i = elems.length - 1; i >= 0; i-- ) {
		log( '  -> Proccessing: ' + unescape( elems[i].name ) + ' / ' + elems[i].type );
		var elemsType = elems[i].type;
		var hasMask = ( null != elems[i].mask ) ? true : false;
		var actualParent = ( hasMask ) ? createMask( parent, elems[i] ) : parent;

		switch ( elemsType ) {
			case 'layer':
				if ( elems[i].hasChildren ) {
					log( '     Type: Layer' );
					shape = createGroup( parent, elems[i], true );
					createElements( shape, elems[i].elems );
					if ( 5 > json2Layer.appVer.minor ) {
						shape.resizeRoot( false );
					} else {
						shape.resizeToFitChildrenWithOption( false );
					}
				}
				break;

			case 'text':
				log( '     Type: Text: ' + unescape( elems[i].textChars ));
				var shape = createText( actualParent, elems[i], isMask );
				shape.setName( unescape( elems[i].textChars ));
				break;

			case 'bitmap':
				log( '     Type: Bitmap' );
				var shape = importBitmap( actualParent, elems[i], isMask );
				addContextSettings( shape, elems[i] );
				break;

			case 'rectangle':
				log( '     Type: Rectangle' );
				var shape = createRectangle( actualParent, elems[i], isMask );

				shape.setName( unescape( elems[i].name ));
				addContextSettings( shape, elems[i] );
				addPathAttributes( shape, elems[i].pathAttributes, isMask );
				break;

			case 'path':
				log( '     Type: Bezier Path' );
				var shape = addBezier( actualParent, elems[i].bezierPath, isMask );
				shape.setName( unescape( elems[i].name ));
				addContextSettings( shape, elems[i] );
				actualParent.addLayers( [shape] );
				addPathAttributes( shape, elems[i].pathAttributes, isMask );
				break;

			case 'slice':
				log( '     Type: Slice' );
				var shape = createSlice( actualParent, elems[i], isMask );
				break;

			case 'group':
				log( '     Type: Layer Group' );
				var shape = createGroup( actualParent, elems[i], isMask );
				addContextSettings( shape, elems[i] );
				createElements( shape, elems[i].elements );

				if ( 5 > json2Layer.appVer.minor ) {
					shape.resizeRoot( false );
				} else {
					shape.resizeToFitChildrenWithOption( false );
				}
				break;

			case 'symbol':
				log( '     Type: Layer Group - Symbol' );
				if ( 7 <= json2Layer.appVer.minor ) {
					if ( json2Layer.symbols[elems[i].elements] ) {
						var shape = json2Layer.symbols[elems[i].elements].newSymbolInstance();
						actualParent.addLayers( [shape] );
					} else {
						while ( 'MSPage' != actualParent.class() ) {
							actualParent = actualParent.parentObject();
						}
						json2Layer.symbolMaster.create( actualParent, json2Layer.orgSymbols[elems[i].elements], elems[i].elements );
						var shape = json2Layer.symbols[elems[i].elements].newSymbolInstance();
						parent.addLayers( [shape] );
					}
					shape.setName( elems[i].name );
					shape.frame().setX( elems[i].left );
					shape.frame().setY( elems[i].top );
				} else {
					var registeredSymbol = false;
					var slc = 0;
					for ( slc = json2Layer.symbols.length - 1; slc >= 0; slc-- ) {
						if ( json2Layer.symbols[slc].fwSymbolID == elems[i].symbolID
						     && json2Layer.symbols[slc].width   == elems[i].width
						     && json2Layer.symbols[slc].height  == elems[i].height
						) {
							registeredSymbol = true;
							break;
						}
					}
					if ( registeredSymbol ) {
						var shape = addSymbol( actualParent, elems[i], slc );
					} else {
						var shape = createSymbol( actualParent, elems[i] );
					}
					break;
				}
			}

		if ( null != elems[i].effectList ) {
			addEffects( shape, elems[i].effectList.effects );
		}

		if ( hasMask ) {
			if ( 5 > json2Layer.appVer.minor ) {
				actualParent.resizeRoot( false );
			} else {
				actualParent.resizeToFitChildrenWithOption( false );
			}
		}

		shape.isLocked = elems[i].locked;
		shape.isVisible = elems[i].visible;
	};

	if ( !isMask ) {
		log( '!!! Finished createElements !!!');
		log( '!!! resizeRoot() to ' + parent.name() );
		if ( 5 > json2Layer.appVer.minor ) {
			parent.resizeRoot( false );
		} else {
			parent.resizeToFitChildrenWithOption( false );
		}
	}

	return shape;
}

function addContextSettings( shape, attrs ) {
	var contextSettings = shape.style().contextSettings();
	contextSettings.opacity = Math.round( attrs.opacity ) / 100;
	if ( json2Layer.blendMode[attrs.blendMode] ) {
		contextSettings.blendMode = json2Layer.blendMode[attrs.blendMode];
	}
}

function setFrame( targetLayer, attrs, parent ) {
	log( '     -> setFrame()' );
	// log( parent );
	// log( parent.absoluteRect() );
	// log( parent.frame() );
	var offsetX2 = parent ? parent.absoluteRect().x() : 0;
	var offsetY2 = parent ? parent.absoluteRect().y() : 0;
	var offsetX = parent ? parent.frame().x() : 0;
	var offsetY = parent ? parent.frame().y() : 0;
	log( attrs );
	log( '        offset: X:' + offsetX + ' / ' + offsetX2 + ', Y: ' + offsetY + ' / ' + offsetY2 );
	log( '        attrs: x:' + attrs.left + ', Y: ' + attrs.top );
	if ( targetLayer.parentObject()
		&& targetLayer.parentObject().length()
		&& targetLayer.parentObject().firstObject().hasClippingMask() ) {
		offsetX = targetLayer.parentObject().parentObject().frame().x();
		offsetY = targetLayer.parentObject().parentObject().frame().y();
		targetLayer.frame().x = attrs.left - offsetX;
		targetLayer.frame().y = attrs.top  - offsetY;
	} else {
		targetLayer.frame().x = attrs.left - offsetX;
		targetLayer.frame().y = attrs.top  - offsetY;
	}
	targetLayer.frame().width = attrs.width;
	targetLayer.frame().height = attrs.height;
	log( targetLayer.treeAsDictionary() );
	log( '     finish setFrame() <-' );

	return targetLayer;
}

function addPathAttributes( shape, attrs, maskMode ) {
	maskMode = maskMode || false;

	if ( null != attrs.fill ) {
		var fill = shape.style().fills().addNewStylePart();

		if ( 'gradient' == attrs.fillType ) {
			addGradientFill( shape, attrs );
		} else if ( 'pattern' == attrs.fillType ) {
			addPatternFill( shape, attrs.fill.pattern.patternURI );
		} else {
			var color = MSColor.colorWithSVGString( getHexColor( attrs.fillColor ) );
			color.alpha = getOpacity( attrs.fillColor );
			fill.color = color;
		}
		if ( 'mask to path' == maskMode ) shape.style().fills().firstObject().isEnabled = false;
		if ( 'mask to image' == maskMode ) convertFilltoAlpha( shape, attrs.fillType );

		if ( 0 < attrs.fill.textureBlend && attrs.fillTexture.filePath && !maskMode ) {
			addTextureFill( shape, attrs );
		} else if ( 0 < attrs.fill.textureBlend && !maskMode ) {
			shape.name = unescape( shape.name() ) + ' [texture not found]';
		}
	}

	if ( null != attrs.brush ) {
		addBorder( shape, attrs );

		if ( 'mask to path' == maskMode ) shape.style().borders().firstObject().isEnabled = false;
	}
}

function addBorder( shape, attrs ) {
	var border = shape.style().borders().addNewStylePart();
	var color = MSColor.colorWithSVGString( getHexColor( attrs.brushColor ) );
	color.alpha = getOpacity( attrs.brushColor );
	border.color = color;
	border.thickness = attrs.brush.diameter;
	switch ( attrs.brushPlacement ) {
		case 'center':
			border.setPosition( 0 );
			break; 
		case 'inside':
			border.setPosition( 1 );
			break; 
		case 'outside':
			border.setPosition( 2 );
			break; 
		default:
			border.setPosition( 0 );
			break; 
	}

	var borderOptions = shape.style();
	switch ( attrs.brush.shape ) {
		case 'square':
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
		case 'circle':
			borderOptions.borderOptions().setLineCapStyle( 1 );
			borderOptions.borderOptions().setLineJoinStyle( 1 );
			break; 
		default:
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
	}

	if ( 1 == attrs.brush.numDashes || 2 == attrs.brush.numDashes ) {
		var dashAttrs = [];
		var gapOffest = attrs.brush.shape == 'circle' ? attrs.brush.diameter : 0;
		for ( var i = 0; i < attrs.brush.numDashes; i++ ) {
			dashAttrs[i * 2] = attrs.brush['dashOnSize' + ( i + 1 )];
			dashAttrs[i * 2 + 1] = attrs.brush['dashOffSize' + ( i + 1 )] + gapOffest;
		}
		borderOptions.borderOptions().setDashPattern( dashAttrs );
	}
}

function addEffects( shape, attrs ) {
	for ( var i = attrs.length - 1; i >= 0; i-- ) {
		log( '  Applied Effect: ' + attrs[i].name );

		if ( attrs[i].EffectIsVisible ) {
			switch ( attrs[i].name ) {
				case 'drop shadow':
					var effect = shape.style().shadows().addNewStylePart();
					effect.blurRadius = attrs[i].ShadowBlur;
					
					var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
					effect.offsetX = coord.x;
					effect.offsetY = coord.y;
					effect.spread = 0;

					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
					color.alpha = getOpacity( attrs[i].ShadowColor );
					effect.color = color;
					break;
				case 'inner shadow':
					var effect = shape.style().innerShadows().addNewStylePart();
					effect.blurRadius = attrs[i].ShadowBlur;
					
					var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
					effect.offsetX = coord.x;
					effect.offsetY = coord.y;
					effect.spread = 0;

					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
					color.alpha = getOpacity( attrs[i].ShadowColor );
					effect.color = color;
					break;
				case 'glow':
					switch( attrs[i].BevelType + '' ) {
						case '4':
							var effect = shape.style().shadows().addNewStylePart();
							effect.blurRadius = attrs[i].MaskSoftness;

							effect.offsetX = 0;
							effect.offsetY = 0;
							effect.spread = attrs[i].GlowWidth;

							var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
							color.alpha = attrs[i].BevelContrast / 100;
							effect.color = color;
							break;
					}
					break;
				case 'inner glow':
					var effect = shape.style().innerShadows().addNewStylePart();
					effect.blurRadius = attrs[i].MaskSoftness;
					
					effect.offsetX = 0;
					effect.offsetY = 0;
					effect.spread = attrs[i].GlowWidth;

					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
					color.alpha = attrs[i].BevelContrast / 100;
					effect.color = color;
					break;
				case 'solid shadow':
					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].color ) );
					color.alpha = 1;

					for ( var j = attrs[i].distance - 1; j >= 0; j-- ) {
						var effect = shape.style().shadows().addNewStylePart();
						effect.blurRadius = 0;
						
						var coord = getCoordfromTrigFunc( attrs[i].distance, attrs[i].angle );
						effect.offsetX = coord.x * (( j + 1 ) / attrs[i].distance );
						effect.offsetY = coord.y * (( j + 1 ) / attrs[i].distance );
						effect.spread = 0;

						effect.color = color;
					};
					break;
				case 'gaussian blur':
					var effect = shape.style().blur();
					effect.isEnabled = 1;
					effect.type = 0;
					effect.radius = attrs[i].gaussian_blur_radius;
					break;
				case 'motion blur':
					var effect = shape.style().blur();
					effect.isEnabled = 1;
					effect.type = 1;
					effect.radius = attrs[i].motion_blur_distance / 2;
					effect.motionAngle = attrs[i].motion_blur_angle;
					break;
				case 'zoom blur':
					var effect = shape.style().blur();
					effect.isEnabled = 1;
					effect.type = 2;
					effect.radius = attrs[i].zoom_blur_amount / 2;
					break;
				case 'add noise':
					var effect = shape.style().fills().addNewStylePart();
					effect.fillType = 5;
					if ( attrs[i].add_noise_use_color ) {
						effect.noiseIndex = 3;
					} else {
						effect.noiseIndex = 2;
					}
					effect.contextSettings().blendMode = 9;
					effect.contextSettings().opacity = Math.round( attrs[i].add_noise_amount / 4 ) / 100;
					break;
				case 'color fill':
					var effect = shape.style().fills().addNewStylePart();
					effect.setFillType(0);
					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].Color ) );
					color.alpha = attrs[i].Opacity / 100;
					effect.contextSettings().blendMode = json2Layer.solidFill[attrs[i].Blendmode];
					effect.color = color;
					break;
				case 'photoshop live effects':
					// log( '  PsLE:' );
					for ( var j = json2Layer.PsLE.length - 1; j >= 0; j-- ) {
						// log( '    Flag: ' + json2Layer.PsLE[j] + ': ' + attrs[i][json2Layer.PsLE[j]].substring( 0, 1 ) );
						if( attrs[i][json2Layer.PsLE[j]] && '1' == attrs[i][json2Layer.PsLE[j]].substring( 0, 1 ) ) {
							// log( '      isEnabled:' );
							var psleAttrs = attrs[i][json2Layer.PsLE[j]].split( '&' );
							// log( '      psleAttrs:' );
							// log( psleAttrs );
							switch ( json2Layer.PsLE[j] ) {
								case 'satin':
									break;
								case 'dropShadow':
									var effect = shape.style().shadows().addNewStylePart();
									effect.blurRadius = psleAttrs[6];
									
									var coord = getCoordfromTrigFunc( psleAttrs[5], psleAttrs[3], true );
									effect.offsetX = coord.x;
									effect.offsetY = coord.y;
									effect.spread = psleAttrs[7];

									var originColor = psleAttrs[11].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									effect.color = color;
									break;
								case 'innerShadow':
									var effect = shape.style().innerShadows().addNewStylePart();
									effect.blurRadius = psleAttrs[6];
									
									var coord = getCoordfromTrigFunc( psleAttrs[5], psleAttrs[3], true );
									effect.offsetX = coord.x;
									effect.offsetY = coord.y;
									effect.spread = psleAttrs[7];

									var originColor = psleAttrs[11].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									effect.color = color;
									break;
								case 'outerGlow':
									var effect = shape.style().shadows().addNewStylePart();
									var subAttrs = psleAttrs[3].split( ':' );
									effect.blurRadius = subAttrs[2];
									
									effect.offsetX = 0;
									effect.offsetY = 0;
									effect.spread = subAttrs[1];

									var originColor = psleAttrs[5].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = subAttrs[0] / 100;
									effect.color = color;

									var blendMode = psleAttrs[2];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									break;
								case 'innerGlow':
									var effect = shape.style().innerShadows().addNewStylePart();
									var subAttrs = psleAttrs[3].split( ':' );
									effect.blurRadius = subAttrs[2];
									
									effect.offsetX = 0;
									effect.offsetY = 0;
									effect.spread = subAttrs[1];

									var originColor = psleAttrs[5].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = subAttrs[0] / 100;
									effect.color = color;
									
									var blendMode = psleAttrs[2];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									break;
								case 'solidFill':
									var effect = shape.style().fills().addNewStylePart();
									effect.setFillType(0);
									var originColor = psleAttrs[3].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									var blendMode = psleAttrs[2];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									effect.color = color;
									break;
								case 'gradientFill':
									var effect = shape.style().fills().addNewStylePart();
									effect.setFillType(1);
									// log( '      opacity: ' + ( psleAttrs[3] ) );
									// log( '      opacity: ' + ( psleAttrs[3] / 100 ) );
									effect.contextSettings().opacity = psleAttrs[3] / 100;
									var coord = getCoordfromTrigFunc( 1, psleAttrs[4], true );
									var coordStretch = ( Math.abs( coord.x ) > Math.abs( coord.y ) ) ? 1 / Math.abs( coord.x ) : 1 / Math.abs( coord.y );
									coord.x = coord.x * coordStretch;
									coord.y = coord.y * coordStretch;
									var startX = 0;
									var startY = 0;
									// offset coordinate
									if ( 0 > coord.x ) {
										startX = startX + Math.abs( coord.x );
										coord.x = 0;
									}
									if ( 0 > coord.y ) {
										startY = startY + Math.abs( coord.y );
										coord.y = 0;
									}
									effect.gradient().setPoint_atIndex_( CGPointMake( startX, startY ), 0 )
									effect.gradient().setPoint_atIndex_( CGPointMake( coord.x, coord.y ), 1 )
									break;
								case 'patternFill':
									break;
								case 'bevelEmboss':
									break;
								case 'stroke':
									var effect = shape.style().borders().addNewStylePart();
									var originColor = psleAttrs[4].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									effect.color = color;
									effect.thickness = psleAttrs[2];
									var blendMode = psleAttrs[3];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									switch ( psleAttrs[5] ) {
										case 'centeredFrame':
											effect.setPosition( 0 );
											break; 
										case 'insetFrame':
											effect.setPosition( 1 );
											break; 
										case 'outsetFrame':
											effect.setPosition( 2 );
											break; 
										default:
											effect.setPosition( 0 );
											break; 
									}
									break;
							}
						}
					};
			}
		}
	};
}

function importBitmap( parent, attrs, isMask ) {
	var filePath = attrs.uri;
	var splitPath = filePath.split( json2Layer.resPath.basePath );
	filePath = json2Layer.resPath.basePath + splitPath[1];

	var bitmap = MSBitmapLayer.bitmapLayerWithImageFromPath( filePath.toString() );
	bitmap = setFrame( bitmap, attrs, ( isMask ? parent : false ) );
	bitmap.name = attrs.name;

	parent.addLayers( [bitmap] );

	return bitmap;
}

function createMask( parent, attrs ) {
	log( '    -> createMask' );

	var maskGroup = parent.addLayerOfType( 'group' );
	maskGroup.setName( attrs.name );

	var mask = createElements( maskGroup, attrs.mask.element, attrs.mask.mode );
	log( '     Mask Object: ' + mask.frame() );

	mask.setHasClippingMask( true );

	if ( 'mask to path' == attrs.mask.mode ) {
		mask.clippingMaskMode = 0; // Outline
	} else {
		mask.clippingMaskMode = 1; // Alpha
	}

	return maskGroup;
}

function createGroup( parent, attrs, _isLayer ) {
	log( '    -> createGroup' );

	var isLayer = _isLayer || false;	
	var group = parent.addLayerOfType( 'group' );
	group.setName( unescape( attrs.name ) || unescape( attrs.name ) );
	group.hasClickThrough = ( isLayer ) ? 1 : 0;

	return group;
}

function createText( parent, attrs, isMask ) {
	var text = parent.addLayerOfType( 'text' );
	// text = setFrame( text, attrs, ( isMask ? parent : false ) );
	if ( !attrs.autoExpand ) {
		text.textBehaviour = 1;
	}

	var textPart = [0];
	var textPartNum = attrs.textRuns.length;
	text.stringValue = '';
	for ( var i = 0; i < textPartNum; i++ ) {
		log( unescape( attrs.textRuns[i].characters ) + attrs.textRuns[i].characters );
		text.stringValue = text.stringValue() + unescape( attrs.textRuns[i].characters );
		textPart.push( textPart[i] + attrs.textRuns[i].characters.length );
	}

	text.usesNewLineSpacingBehaviour = 1;
	if ( 1 < textPartNum ) {
		for ( var i = 0; i < textPartNum; i++ ) {
			var range = NSMakeRange( textPart[i], textPart[i + 1] - textPart[i] );
			var textFont = NSFont.fontWithName_size_( attrs.textRuns[i].face, attrs.textRuns[i].size );
			var color = hex2Color( attrs.textRuns[i].fillColor );
			var pragraph = NSMutableParagraphStyle.new()
			pragraph.minimumLineHeight = attrs.textRuns[i].leading;
			pragraph.maximumLineHeight = attrs.textRuns[i].leading;

			text.setIsEditingText( true );
			text.addAttribute_value_forRange_( NSFontAttributeName, textFont, range );
			text.addAttribute_value_forRange_( NSForegroundColorAttributeName, color, range );
			text.addAttribute_value_forRange_( NSParagraphStyleAttributeName, pragraph, range );
			text.setIsEditingText( false );
		}
	} else {
		text.fontSize           = attrs.fontSize;
		text.fontPostscriptName = attrs.fontFace;
		text.textColor          = MSColor.colorWithSVGString( attrs.fillColor );

		var pragraph = NSMutableParagraphStyle.new()
		pragraph.minimumLineHeight = attrs.leading;
		pragraph.maximumLineHeight = attrs.leading;
		text.addAttribute_value_( NSParagraphStyleAttributeName, pragraph );
	}
	text = setFrame( text, attrs, ( isMask ? parent : false ) );

	// Ajust bounding
	if ( 6 <= json2Layer.appVer.minor ) {
		text.frame().y = text.frame().y() - Math.round( ( attrs.leading - attrs.fontSize ) / 4 );
		text.frame().height = attrs.leading;
	}
	
	switch ( attrs.alignment ) {
		case 'left':
			text.setTextAlignment( 0 );
			break;
		case 'right':
			text.setTextAlignment( 1 );
			break;
		case 'center':
			text.setTextAlignment( 2 );
			break;
		default:
			text.setTextAlignment( 0 );
			break;
	}

	applyRotation( text, attrs.transform.matrix[3] );
	
	return text;
}

function createRectangle( parent, attrs, isMask ) {
	var originMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	var isTransform = false;
	
	for (var i = 0; i < originMatrix.length; i++) {
		if ( originMatrix[i] != attrs.transform.matrix[i] && ( 0 != i && 4 != i && 6 != i && 7 != i) ) {
			isTransform = true;
			break;
		}
	}
	var m = attrs.transform.matrix;
	var ow = attrs.originalSides['right'] - attrs.originalSides['left'],
	    oh = attrs.originalSides['bottom'] - attrs.originalSides['top'];
	var ol = attrs.originalSides['left'],
	    ot = attrs.originalSides['top'],
	    ob = attrs.originalSides['bottom'],
	    or = attrs.originalSides['right'];
	var bounds = [
		attrs.left,               attrs.top,
		attrs.left + attrs.width, attrs.top,
		attrs.left + attrs.width, attrs.top + attrs.height,
		attrs.left,               attrs.top + attrs.height
	];

	if ( isTransform ) {
		var rectangle = NSBezierPath.bezierPath();

		// a d g b e h c f i
		// 0 1 2 3 4 5 6 7 8
		// u = (x*a + y*b + c) / (x*g + y*h + 1)
		// v = (x*d + y*e + f) / (x*g + y*h + 1)
		// X1 = x1 * a + y1 * b + c − x1 * g * X1 − y1 * h * X1
		// Y1 = x1 * d + y1 * e + f − x1 * g * Y1 − y1 * h * Y1

		var vector = [];
		vector.push(( ol * m[0] + ot * m[3] + m[6] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( ol * m[1] + ot * m[4] + m[7] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( or * m[0] + ot * m[3] + m[6] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( or * m[1] + ot * m[4] + m[7] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( or * m[0] + ob * m[3] + m[6] ) / ( or * m[2] + ob * m[5] + m[8] ));
		vector.push(( or * m[1] + ob * m[4] + m[7] ) / ( or * m[2] + ob * m[5] + m[8] ));
		vector.push(( ol * m[0] + ob * m[3] + m[6] ) / ( ol * m[2] + ob * m[5] + m[8] ));
		vector.push(( ol * m[1] + ob * m[4] + m[7] ) / ( ol * m[2] + ob * m[5] + m[8] ));

		var matrix = [];
		matrix.push( ol * m[0] + ot * m[3] + m[6] - ol * m[2] * vector[0] - ot * m[5] * vector[0] );
		matrix.push( ol * m[1] + ot * m[4] + m[7] - ol * m[2] * vector[1] - ot * m[5] * vector[1] );
		matrix.push( or * m[0] + ot * m[3] + m[6] - or * m[2] * vector[2] - ot * m[5] * vector[2] );
		matrix.push( or * m[1] + ot * m[4] + m[7] - or * m[2] * vector[3] - ot * m[5] * vector[3] );
		matrix.push( or * m[0] + ob * m[3] + m[6] - or * m[2] * vector[4] - ob * m[5] * vector[4] );
		matrix.push( or * m[1] + ob * m[4] + m[7] - or * m[2] * vector[5] - ob * m[5] * vector[5] );
		matrix.push( ol * m[0] + ob * m[3] + m[6] - ol * m[2] * vector[6] - ob * m[5] * vector[6] );
		matrix.push( ol * m[1] + ob * m[4] + m[7] - ol * m[2] * vector[7] - ob * m[5] * vector[7] );

		rectangle.moveToPoint( NSMakePoint( matrix[0] / m[8], matrix[1] / m[8] ));
		rectangle.lineToPoint( NSMakePoint( matrix[2] / m[8], matrix[3] / m[8] ));
		rectangle.lineToPoint( NSMakePoint( matrix[4] / m[8], matrix[5] / m[8] ));
		rectangle.lineToPoint( NSMakePoint( matrix[6] / m[8], matrix[7] / m[8] ));
		rectangle.closePath();

		var shape = MSShapeGroup.shapeWithBezierPath( rectangle );
		for (var i = 0; i < shape.layers().firstObject().path().points().length(); i++) {
			shape.layers().firstObject().path().points().objectAtIndex( i ).setCornerRadius( attrs.radius * m[8] );
		}
		parent.addLayers( [shape] );
	} else {
		var rectangle = MSRectangleShape.new();
		rectangle.frame().width = attrs.width;
		rectangle.frame().height = attrs.height;
		var shape = MSShapeGroup.shapeWithPath( rectangle );
		var offsetX = ( 'MSLayerGroup' == parent.class() ) ? parent.frame().x() : 0;
		var offsetY = ( 'MSLayerGroup' == parent.class() ) ? parent.frame().y() : 0;
		shape.frame().x = attrs.left - offsetX;
		shape.frame().y = attrs.top - offsetY;
		parent.addLayers( [shape] );
		shape.layers().firstObject().cornerRadiusFloat = attrs.radius * m[0];
	}
	// parent.addLayers( [shape] );

	return shape;
}

function createSlice( parent, attrs, isMask ) {
	var slice = MSSliceLayer.new();
	slice = setFrame( slice, attrs, ( isMask ? parent : false ) );
	slice.setName( unescape( attrs.baseName ));

	parent.addSlice( slice );

	return slice;
}

function addBezier( parent, attrs, isMask ) {
	var bezierLine = NSBezierPath.bezierPath();
	log( '     -> addBezier Parent Frame' );
	// log( parent.frame() );

	// var offsetX = parent ? parent.absoluteRect().x() : 0;
	// var offsetY = parent ? parent.absoluteRect().y() : 0;
	var offsetX = 0;
	var offsetY = 0;
	log ( '        -> Offset: ' + offsetX + ' / ' + offsetY );

	for ( var i = 0; i < attrs.length; i ++ ) {
		var nodes = attrs[i].nodes;
		bezierLine.moveToPoint( NSMakePoint( nodes[0].x - offsetX, nodes[0].y - offsetY ) );

		for ( var j = 1; j < nodes.length; j++ ) {
			var ancher        = NSMakePoint( nodes[j].x - offsetX, nodes[j].y - offsetY );
			var currentHandle = NSMakePoint( nodes[j].predX - offsetX,   nodes[j].predY - offsetY );
			var prevHandle    = NSMakePoint( nodes[j - 1].succX - offsetX, nodes[j - 1].succY - offsetY );
			// log( 'ancher:        ' + ancher );
			// log( 'currentHandle: ' + currentHandle );
			// log( 'prevHandle:    ' + prevHandle );
			[bezierLine curveToPoint:ancher controlPoint1:prevHandle controlPoint2:currentHandle];
		};
		if ( attrs[i].isClosed ) {
			[bezierLine 
				curveToPoint:NSMakePoint( nodes[0].x - offsetX, nodes[0].y - offsetY ) 
				controlPoint1:NSMakePoint( nodes[nodes.length - 1].succX - offsetX, nodes[nodes.length - 1].succY - offsetY )
				controlPoint2:NSMakePoint( nodes[0].predX - offsetX, nodes[0].predY - offsetY )
			];
			bezierLine.closePath();
			// log( 'closed-ancher:        ' + NSMakePoint( nodes[0].x, nodes[0].y ) );
			// log( 'closed-currentHandle: ' + NSMakePoint( nodes[nodes.length - 1].succX, nodes[nodes.length - 1].succY ) );
			// log( 'closed-prevHandle:    ' + NSMakePoint( nodes[0].predX, nodes[0].predY ) );
		}
	}
	var shape = MSShapeGroup.shapeWithBezierPath( bezierLine );

	return shape;
}

function createSymbol( parent, attrs ) {
	log( '           Create Symbol' );

	var shape = createGroup( parent, attrs );
	shape.setName( unescape( attrs.symbolName ));
	addContextSettings( shape, attrs );
	createElements( shape, json2Layer.orgSymbols[attrs.elements].elements );
	if ( 5 > json2Layer.appVer.minor ) {
		shape.resizeRoot( false );
	} else {
		shape.resizeToFitChildrenWithOption( false );
	}

	var symbols = json2Layer.doc.documentData().layerSymbols();
	symbols.addSymbolWithName_firstInstance( attrs.symbolName, shape );

	var shape = parent.layers().objectAtIndex( parent.layers().count() - 1 );
	shape.frame().x = attrs.left;
	shape.frame().y = attrs.top;

	json2Layer.symbols.push( 
		{ 
			fwSymbolID: attrs.symbolID,
			width: attrs.width, 
			height: attrs.height,
			symbolID: shape.sharedObjectID()
		}
	);

	return shape;
}

function addSymbol( parent, attrs, symbolIndex ) {
	log( '           Exist Symbol' );
	var symbol = json2Layer.doc.documentData().layerSymbols().symbolAtIndex( symbolIndex );
	var shape = symbol.newInstance();
	shape.setName( unescape( attrs.name ));
	shape.frame().x = attrs.left;
	shape.frame().y = attrs.top;
	parent.addLayers( [shape] );
	// doc.reloadInspector();

	return shape;
}

function setGrid( parent, gridAttrs ) {
	var grid = MSSimpleGrid.new();
	grid.setGridSize( gridAttrs.gridSize.x );
	parent.grid = grid;
}

function addGuideline ( parent, guides, grid ) {
	var vRuler = parent.verticalRulerData();
	var hRuler = parent.horizontalRulerData();

	// set origin
	hRuler.setBase( grid.x );
	vRuler.setBase( grid.y );

	// set guidelines
	for ( var i in guides.x ) {
		hRuler.addGuideWithValue( guides.x[i] );
	}
	for ( var i in guides.y ) {
		vRuler.addGuideWithValue( guides.y[i] );
	}
}

function addTextureFill( shape, attrs ) {
	var splitPath = attrs.fillTexture.filePath.split( json2Layer.resPath.basePath );
	var filePath = json2Layer.resPath.basePath + splitPath[1];
	var texturePath = NSImage.new().initWithContentsOfFile( filePath );
	var textureFill = shape.style().fills().addNewStylePart();
	
	textureFill.setFillType( 4 );
	textureFill.setPatternFillType( 0 );

	if ( 5 > json2Layer.appVer.minor ) {
		var fillCollection = textureFill.documentData().images();
		textureFill.setPatternImage_collection_( texturePath, fillCollection );
	} else {
		textureFill.setPatternImage( texturePath );
	}

	var contextSettings = textureFill.contextSettings();
	contextSettings.opacity = attrs.fill.textureBlend / 100;
	contextSettings.blendMode = json2Layer.blendMode['screen'];
}

function addPatternFill( shape, attrs ) {
	var splitPath = attrs.split( json2Layer.resPath.basePath );
	var filePath = json2Layer.resPath.basePath + splitPath[1];
	var patternPath = NSImage.new().initWithContentsOfFile( filePath );
	var shapeStyle = shape.style();
	var shapeFill = shapeStyle.fill();
	
	shapeFill.setFillType( 4 );
	shapeFill.setPatternFillType( 1 );

	if ( 5 > json2Layer.appVer.minor ) {
		var fillCollection = shapeFill.documentData().images();
		shapeFill.setPatternImage_collection_( patternPath, fillCollection );
	} else {
		shape.style().fills().firstObject().setPatternImage( patternPath );
		shape.style().fills().firstObject().setPatternFillType( 1 );
	}
}

function addGradientFill( shape, pathAttrs ) {
	log( '>>> addGradientFill: ' + pathAttrs.fill.gradient.gradientType );

	var attrs = pathAttrs.fill.gradient;
	var gradientNodes = attrs.nodes.concat( attrs.opacityNodes );

	// sort gradient stops by position
	for ( var i = 0; i < gradientNodes.length - 1; i++ ) {
		for ( var j = gradientNodes.length - 1; j > i; j-- ) {
			if ( gradientNodes[j - 1].position > gradientNodes[j].position ) {
				var exchenge = gradientNodes[j - 1];
				gradientNodes[j - 1] = gradientNodes[j];
				gradientNodes[j] = exchenge;
			}
		};
	};
	// log( 'gradientNodes' );
	// log( gradientNodes );


	var ci = 0, // color index
	    oi = 0; // opacityNodes index
	var optimazedPoints = [];
	for ( var i = 0, index = 0; i < gradientNodes.length; i++ ) {
		optimazedPoints[index] = {};
		if ( gradientNodes.length == i + 1 ) {
			optimazedPoints[index].position = gradientNodes[i].position;
			if ( gradientNodes[i].isOpacityNode ) {
				optimazedPoints[index].opacity  = getOpacityByDigit( gradientNodes[i].color.slice( 7, 9 ) );
				optimazedPoints[index].color = optimazedPoints[index - 1].color;
			} else {
				optimazedPoints[index].opacity  = optimazedPoints[index - 1].opacity;
				optimazedPoints[index].color    = gradientNodes[i].color;
			}
		} else if ( gradientNodes[i].position < gradientNodes[i + 1].position ) {
			if ( gradientNodes[i].isOpacityNode ) {
				optimazedPoints[index].position = gradientNodes[i].position;
				optimazedPoints[index].opacity  = getOpacityByDigit( gradientNodes[i].color.slice( 7, 9 ) );
				if ( 0 == ci || gradientNodes.length == i + 1 ) {
					optimazedPoints[index].color = attrs.nodes[ci].color;
				} else {
					var nodeColor;
					var assets = {prev:{}, next:{}, current:{}};
						assets.prev.position = attrs.nodes[ci - 1].position;
						assets.prev.color  = attrs.nodes[ci - 1].color;
						assets.next.position = attrs.nodes[ci].position;
						assets.next.color  = attrs.nodes[ci].color;
						assets.current.position = optimazedPoints[index].position;

					optimazedPoints[index].color = getGradientStopColorOnOpacitySide( assets );
				}
				index++;
				oi++;
			} else {
				optimazedPoints[index].color    = gradientNodes[i].color;
				optimazedPoints[index].position = gradientNodes[i].position;
				if ( 0 == oi || gradientNodes.length == i + 1 ) {
					var nodeOpacity = attrs.opacityNodes[ci].color.slice( 7, 9 );
					optimazedPoints[index].opacity  = getOpacityByDigit( nodeOpacity );
				} else {
					var nodeOpacity;
					var assets = {prev:{}, next:{}, current:{}};
						assets.prev.position = attrs.opacityNodes[oi - 1].position;
						nodeOpacity          = attrs.opacityNodes[oi - 1].color.slice( 7, 9 );
						assets.prev.opacity  = getOpacityByDigit( nodeOpacity );
						assets.next.position = attrs.opacityNodes[oi].position;
						nodeOpacity          = attrs.opacityNodes[oi].color.slice( 7, 9 );
						assets.next.opacity  = getOpacityByDigit( nodeOpacity );
						assets.current.position = optimazedPoints[index].position;

					optimazedPoints[index].opacity = getGradientOpacity( assets );
				}
				index++;
				ci++;
			}

		} else if ( gradientNodes[i].position == gradientNodes[i + 1].position ) {
			optimazedPoints[index].color    = gradientNodes[i].color;
			optimazedPoints[index].position = gradientNodes[i].position;
			optimazedPoints[index].opacity  = getOpacityByDigit( gradientNodes[i + 1].color.slice( 7, 9 ) );
			index++;
			i++;
			ci++;
			oi++;
		}
	}

	var shapeStyle = shape.style();
	// shapeStyle.fills().addNewStylePart();
	var shapeFill = shapeStyle.fill();
	shapeFill.setFillType( 1 ); // gradient fill

	var gradient = shapeFill.gradient();
	switch ( attrs.gradientType ) {
		case 'linear':
			gradient.setGradientType( 0 );
			break;
		case 'radial':
		case 'elliptical':
			gradient.setGradientType( 1 );
			break;
		case 'conical':
			gradient.setGradientType( 2 );
			break;
		default:
			gradient.setGradientType( 0 );
			break;
	}

	var orignPoint = optimazedPoints.length;
	for ( var i = 0; i < orignPoint; i++ ) {
		if ( 0 != optimazedPoints[i].position && 1 != optimazedPoints[i].position ) {
			gradient.addStopAtLength( roundWithDigit( optimazedPoints[i].position, 2 ) );
		}
	}
	for ( var i = 0; i < orignPoint; i++ ) {
		var gradientColor = MSColor.colorWithSVGString( optimazedPoints[i].color );
		gradientColor.alpha = optimazedPoints[i].opacity;
		gradient.setColor_atIndex_( gradientColor, i );
	}

	var shapeX = shape.frame().x();
	var shapeY = shape.frame().y();
	var shapeW = shape.frame().width();
	var shapeH = shape.frame().height();
	var startX = ( pathAttrs.fillHandle1.x - shapeX ) / shapeW;
	var startY = ( pathAttrs.fillHandle1.y - shapeY ) / shapeH;
	var endX = ( pathAttrs.fillHandle2.x - shapeX ) / shapeW;
	var endY = ( pathAttrs.fillHandle2.y - shapeY ) / shapeH;
	if ( 'elliptical' == attrs.gradientType ) {
		var handlePoint1x = pathAttrs.fillHandle2.x - pathAttrs.fillHandle1.x;
		var handlePoint1y = pathAttrs.fillHandle2.y - pathAttrs.fillHandle1.y;
		if ( 0 != handlePoint1x && 0 != handlePoint1y ) {
			var handle1Length = Math.sqrt( handlePoint1x * handlePoint1x + handlePoint2y * handlePoint2y );
		} else {
			var handle1Length = ( 0 != handlePoint1x ) ? handlePoint1x : handlePoint1y;
		}
		var handlePoint2x = pathAttrs.fillHandle3.x - pathAttrs.fillHandle1.x;
		var handlePoint2y = pathAttrs.fillHandle3.y - pathAttrs.fillHandle1.y;
		if ( 0 != handlePoint2x && 0 != handlePoint2y ) {
			var handle2Length = Math.sqrt( handlePoint2x * handlePoint2x + handlePoint2y * handlePoint2y );
		} else {
			var handle2Length = ( 0 != handlePoint2x ) ? handlePoint2x : handlePoint2y;
		}
		gradient.elipseLength = Math.abs( handle2Length / handle1Length );
	}
	if ( 'conical' != attrs.gradientType ) {
		gradient.from = CGPointMake( startX, startY );
		gradient.setPoint_atIndex_( CGPointMake( startX, startY ), 0 );
		gradient.setPoint_atIndex_( CGPointMake( endX, endY ), orignPoint - 1 );
	} else {
		for ( var i = 0; i < gradient.stops().length(); i++ ) {
			gradient.stops().objectAtIndex( i ).position = gradient.stops().objectAtIndex( i ).position() / 2;
		}
		var originalStops = gradient.stops().length();
		for ( var i = 0; i < originalStops; i++ ) {
			if ( 0 != gradient.stops().objectAtIndex( i ).position() 
				 && 0.5 != gradient.stops().objectAtIndex( i ).position() ) {
				gradient.addStopAtLength( 1 - gradient.stops().objectAtIndex( i ).position() );
				gradient.setColor_atIndex_( gradient.stops().objectAtIndex( i ).color(), gradient.stops().length() - 1 );
			}
		}
	}
}

function convertFilltoAlpha( shape, fillType ) {
	switch ( fillType ) {
		case 'gradient':
			var gradient = shape.style().fills().firstObject().gradient();
			for ( var i = 0; i < gradient.stops().length(); i++ ) {
				var color = MSColor.colorWithSVGString( '#' + gradient.stops().objectAtIndex(i).color().hexValue().toString() );
				color.alpha = gradient.stops().objectAtIndex(i).color().alpha() * gray2Alpha( gradient.stops().objectAtIndex(i).color().hexValue().toString() );
				gradient.setColor_atIndex_( color, i );
			}
			break;
		case 'flat':
			var fill = shape.style().fills().firstObject();
			var color = MSColor.colorWithSVGString( '#' + fill.color().hexValue().toString() );
			color.alpha = gray2Alpha( fill.color().hexValue().toString() );
			fill.setFillType( 1 );
			var gradient = fill.gradient();
			for ( var i = 0; i < fill.gradient().stops().length(); i++ ) {
				gradient.setColor_atIndex_( color, i );
			}
			break;
	}
}

function applyRotation( shape, radian ) {
	angle = roundWithDigit( 0 - radian * ( 180 / Math.PI ), 2 );
	if ( 0 != angle ) {
		angle = 360 - angle;
		shape.rotation = angle;
	}
}

// utilities
function getCoordfromTrigFunc( radius, angle, isPsLE ) {
	var coord = {}
	if ( !isPsLE ) {
		angle = 360 - angle;
	} else {
		angle = 180 - angle;
	}

	coord.x = radius * Math.cos( angle / 180 * Math.PI );
	coord.y = radius * Math.sin( angle / 180 * Math.PI );

	return coord;
}

function getGradientStopColorOnOpacitySide ( assets ) {
	// log( '    getGradientStopColorOnOpacitySide:');
	// log( assets );

	var pr = hex2Digit( assets.prev.color.slice( 1, 3 ) ) - 0;
	var pg = hex2Digit( assets.prev.color.slice( 3, 5 ) ) - 0;
	var pb = hex2Digit( assets.prev.color.slice( 5, 7 ) ) - 0;

	var nr = hex2Digit( assets.next.color.slice( 1, 3 ) ) - 0;
	var ng = hex2Digit( assets.next.color.slice( 3, 5 ) ) - 0;
	var nb = hex2Digit( assets.next.color.slice( 5, 7 ) ) - 0;

	// log( '    prevColor: ' + pr + ' / ' + pg + ' / ' + pb + ' | nextColor: ' + nr + ' / ' + ng + ' / ' + nb );

	var range = assets.next.position - assets.prev.position;
	var offset = 1 / range;
	// log( '    offset: ' + offset );
	var localRangePosition = ( assets.current.position - assets.prev.position ) * offset;
	// log( '    range: ' + range + ' / offset: ' + offset + ' / localRangePosition: ' + localRangePosition );
	
	var r = roundWithDigit( pr + ( nr - pr ) * localRangePosition, 0 );
	var g = roundWithDigit( pg + ( ng - pg ) * localRangePosition, 0 );
	var b = roundWithDigit( pb + ( nb - pb ) * localRangePosition, 0 );

	r = digit2Hex( r );
	g = digit2Hex( g );
	b = digit2Hex( b );
	// log( '    retrun: ' + '#' + r + g + b );

	return '#' + r + g + b;
}

function getGradientOpacity ( assets ) {
	// log( '    getGradientOpacity:');
	// log( assets );

	var range = assets.next.position - assets.prev.position;
	var offset = 1 / range;
	var localRangePosition = ( assets.current.position - assets.prev.position ) * offset;

	var opacity = roundWithDigit( assets.prev.opacity + ( assets.next.opacity - assets.prev.opacity ) * localRangePosition, 2 );

	return opacity;
}

function floorWithDigit ( _val, _specifiedDigit ) {
	var digit = Math.pow( 10, _specifiedDigit );
	var val = Math.floor( _val * digit );

	return  val / digit;
}

function roundWithDigit ( _val, _specifiedDigit ) {
	var digit = Math.pow( 10, _specifiedDigit );
	var val = Math.round( _val * digit );

	return  val / digit;
}

function getOpacityByDigit ( _hex ) {
	if ( _hex ) {
		var digit = ( parseInt( '0x' + _hex ).toString( 10 ) ) / 255;
	} else {
		var digit = 1;
	}

	return roundWithDigit( digit, 2 );
}

function digit2Hex ( _digit ) {
	var hex = parseInt( _digit ).toString( 16 );
	if ( 1 == hex.length ) hex = '0' + hex;
	return hex;
}

function hex2Digit ( _hex ) {
	return ( parseInt( '0x' + _hex ).toString( 10 ) );
}

function bit2Percent ( val ) {
	return roundWithDigit( val / 255, 4 );
}

function getHexColor( color ) {
	if( 7 == color.length ) return color;
	return color.slice( 0, 7 );
}

function getOpacity( color ) {
	if( 7 == color.length ) return 1;

	var hex = color.slice( 7, 9 );
	var opacity = parseInt( '0x' + hex ).toString( 10 ) / 255;
	opacity = roundWithDigit( opacity, 2 );

	return opacity;
}

function hex2Color ( hex ) {
	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec( hex ),
		red   = parseInt(result[1], 16) / 255,
		green = parseInt(result[2], 16) / 255,
		blue  = parseInt(result[3], 16) / 255,
		alpha = getOpacity( hex );
    return NSColor.colorWithCalibratedRed_green_blue_alpha( red, green, blue, alpha )
}

function rgb2Gray ( hex ) {
	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec( hex ),
		red   = hex2Digit( parseInt( result[1], 16 )) - 0,
		green = hex2Digit( parseInt( result[2], 16 )) - 0,
		blue  = hex2Digit( parseInt( result[3], 16 )) - 0;
	var gray  = digit2Hex(( Math.round( red + green + blue ) / 3 ));
	return '#' + gray + gray + gray;
}

function gray2Alpha ( hex ) {
	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec( hex ),
		red   = parseInt( result[1], 16 ),
		green = parseInt( result[2], 16 ),
		blue  = parseInt( result[3], 16 );

	if ( red != green || green != blue ) {
		hex = rgb2Gray( hex );
		result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec( hex );
	}

	var grayPercent = hex2Digit( result[1] ) - 0;
	return bit2Percent( grayPercent );
}