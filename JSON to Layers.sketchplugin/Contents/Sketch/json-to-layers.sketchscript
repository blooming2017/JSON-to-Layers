@import 'lib/const.js';
@import 'lib/utilities.js';

json2Layer.init = function ( doc ) {
	this.doc = doc;
}

var onRun = function ( context ) {
	// log( 'Start Proccessing ------------------------------------------' );
	json2Layer.init( context.document );
	var doc = json2Layer.doc;
	var currentPage = doc.currentPage();

	var fwJSON = loadJSON();
	if( !fwJSON ) return false;

	json2Layer.symbolMaster.init( doc, fwJSON );

	for ( var i = 0; i < fwJSON.pages.length; i++ ) {
		// log( 'Page: ' + fwJSON.pages[i].pageName + ' //////////////////////////////////////////' );
		for ( var stateIndex = 0; stateIndex < fwJSON.pages[i].frames.length; stateIndex++ ) {
			// log( 'Frame (state): ' + stateIndex + ' ------------------------------------------>' );
			var artboard = json2Layer.artboards.create( fwJSON.pages[i], currentPage, fwJSON.documentSetting.grid );
			fwJSON.pages[i].frames[stateIndex].topLayers.reverse();
			createElements( artboard, fwJSON.pages[i].frames[stateIndex].topLayers );
		};
		json2Layer.artboards.offset( fwJSON.pages[i].width );
	}

	// log( '------------------------------------------ Close Proccessing' );

}

function loadJSON() {
	var openPanel = NSOpenPanel.openPanel();
	    openPanel.setTitle( "Choose a JSON File" );
	    openPanel.setCanCreateDirectories = false;
	    openPanel.setCanChooseFiles = true;

	var fileTypes = ['json'];
	var openPanelButtonPressed = openPanel.runModalForDirectory_file_types_( nil, nil, fileTypes );

	if ( openPanelButtonPressed == NSFileHandlingPanelOKButton ) {
		var filePath = openPanel.URL().path();
		var fwJSON = JSON.parse( NSString.stringWithContentsOfFile( filePath ) ); 
		// log( 'Open File from: ' + filePath );
		json2Layer.orgSymbols = fwJSON.symbols;
		json2Layer.resPath.basePath    = openPanel.directoryURL().path();
		json2Layer.resPath.exportedDir = fwJSON.resExportedDir;
	} else {
		var fwJSON = false;
	}

	return fwJSON;
}

json2Layer.artboards = ( function () {
	var artboardPageOffset  = 0; 
	var artboardStateOffset = 0;

	return {
		create: function( _page, currentPage, _grid ) {
			var artboard = MSArtboardGroup.new();
			artboard.setName( unescape( _page.pageName ));
			artboard.frame().setX( artboardPageOffset );
			artboard.frame().setY( artboardStateOffset );
			artboard.frame().setWidth ( _page.width );
			artboard.frame().setHeight( _page.height );
			artboardStateOffset += _page.height + 100;
			currentPage.addLayers( [artboard] );

			setGrid( artboard, _grid );
			addGuideline( artboard, _page.guides, _grid.gridOrigin );

			return artboard;
		},
		offset: function( _width ) {
			artboardPageOffset += _width + 100;
			artboardStateOffset = 0;
		}
	};
})();

json2Layer.symbolMaster = ( function () {
	var artboardZeroPoint = { x: 0, y: 0 };

	return {
		init: function( doc, fwJSON ) {
			// log( '-> Create Symbol Master' );
			var masterPage = doc.addBlankPage();
			doc.pages().objectAtIndex( doc.pages().count() - 1 ).setName( 'Symbols' );
			json2Layer.symbols = {};
			for ( var symbolID in fwJSON.symbols ) {
				json2Layer.symbolMaster.create( masterPage, fwJSON.symbols[symbolID], symbolID );
			}
			doc.setCurrentPage( doc.pages().objectAtIndex(0) );
			// log( '-> // Create Symbol Master' );
		},
		create: function( parent, symbol, symbolID ) {
			if ( !json2Layer.symbols[symbolID] ) {
				// log( '-> Create Symbol Master: ' + unescape( symbol.symbolName ) );
				var artboard = MSArtboardGroup.new();
				artboard.setName( unescape( symbol.symbolName ) );
				artboard.frame().setX( artboardZeroPoint.x );
				artboard.frame().setY( artboardZeroPoint.y );
				artboard.frame().setWidth( symbol.width );
				artboard.frame().setHeight( symbol.height );
				artboardZeroPoint.x += symbol.width + 100;
				parent.addLayers( [artboard] );

				createElements( artboard, symbol.elements );

				for (var i = artboard.layers().count() - 1; i >= 0; i--) {
					artboard.layers().objectAtIndex( i ).frame().x = artboard.layers().objectAtIndex( i ).frame().x() - symbol.left;
					artboard.layers().objectAtIndex( i ).frame().y = artboard.layers().objectAtIndex( i ).frame().y() - symbol.top;
				}
				json2Layer.symbols[symbolID] = artboard.convertToSymbol();
				// log( '   // Created symbol master: ' + symbol.symbolName );
			}
		}
	};

})();

function createElements( parent, elems, isMask ) {
	// log( '-> Child Layer Processing' );
	if ( !isMask ) isMask = false;

	for ( var i = elems.length - 1; i >= 0; i-- ) {
		log( '  -> Processing: ' + unescape( elems[i].name ) + ' / ' + elems[i].type );
		var elemsType = elems[i].type;
		var hasMask = ( null != elems[i].mask ) ? true : false;
		var actualParent = ( hasMask ) ? createMask( parent, elems[i] ) : parent;

		switch ( elemsType ) {
			case 'layer':
				if ( elems[i].hasChildren ) {
					// log( '     Type: Layer' );
					shape = createGroup( parent, elems[i], true );
					createElements( shape, elems[i].elems );
					shape.resizeToFitChildrenWithOption( false );
				}
				break;

			case 'text':
				// log( '     Type: Text: ' + unescape( elems[i].textChars ));
				var shape = createText( actualParent, elems[i], isMask );

				setLayerName( shape, elems[i].textChars, elems[i].type );
				break;

			case 'bitmap':
				// log( '     Type: Bitmap' );
				var shape = importBitmap( actualParent, elems[i], isMask );
				addContextSettings( shape, elems[i] );
				break;

			case 'rectangle':
				// log( '     Type: Rectangle' );
				var shape = createRectangle( actualParent, elems[i], isMask );

				setLayerName( shape, elems[i].name, elems[i].type );
				addContextSettings( shape, elems[i] );
				addPathAttributes( shape, elems[i].pathAttributes, isMask );
				break;

			case 'path':
				// log( '     Type: Bezier Path' );
				var shape = addBezier( actualParent, elems[i].bezierPath, isMask );

				setLayerName( shape, elems[i].name, elems[i].type );
				addContextSettings( shape, elems[i] );
				actualParent.addLayers( [shape] );
				addPathAttributes( shape, elems[i].pathAttributes, isMask );
				break;

			case 'slice':
				// log( '     Type: Slice' );
				var shape = createSlice( actualParent, elems[i], isMask );
				break;

			case 'group':
				// log( '     Type: Layer Group' );
				var shape = createGroup( actualParent, elems[i], isMask );
				addContextSettings( shape, elems[i] );
				createElements( shape, elems[i].elements );
				shape.resizeToFitChildrenWithOption( false );
				break;

			case 'symbol':
				// log( '     Type: Layer Group - Symbol' );
				if ( json2Layer.symbols[elems[i].elements] ) {
					var shape = json2Layer.symbols[elems[i].elements].newSymbolInstance();
					actualParent.addLayers( [shape] );
				} else {
					while ( 'MSPage' != actualParent.class() ) {
						actualParent = actualParent.parentObject();
					}
					json2Layer.symbolMaster.create( actualParent, json2Layer.orgSymbols[elems[i].elements], elems[i].elements );
					var shape = json2Layer.symbols[elems[i].elements].newSymbolInstance();
					parent.addLayers( [shape] );
				}
				setLayerName( shape, elems[i].name, elems[i].type );
				shape.frame().setX( elems[i].left );
				shape.frame().setY( elems[i].top );
		}

		if ( null != elems[i].effectList ) {
			addEffects( shape, elems[i].effectList.effects );
		}

		if ( hasMask ) {
			actualParent.resizeToFitChildrenWithOption( false );
		}

		shape.isLocked = elems[i].locked;
		shape.isVisible = elems[i].visible;
	};

	if ( !isMask ) {
		// log( '!!! Finished createElements!!! resizeRoot() at ' + parent.name());
		parent.resizeToFitChildrenWithOption( false );
	}

	return shape;
}

function addContextSettings( shape, attrs ) {
	var contextSettings = shape.style().contextSettings();
	contextSettings.opacity = Math.round( attrs.opacity ) / 100;
	if ( json2Layer.blendMode[attrs.blendMode] ) {
		contextSettings.blendMode = json2Layer.blendMode[attrs.blendMode];
	}
}

function setFrame( targetLayer, attrs, parent ) {
	// log( '     -> setFrame()' );
	log( targetLayer );
	var offsetX = parent ? parent.frame().x() : 0;
	var offsetY = parent ? parent.frame().y() : 0;
	if ( targetLayer.parentObject()
		// && targetLayer.parentObject().count()
		&& targetLayer.parentObject().firstLayer().hasClippingMask() ) {
		offsetX = targetLayer.parentObject().parentObject().frame().x();
		offsetY = targetLayer.parentObject().parentObject().frame().y();
		targetLayer.frame().x = attrs.left - offsetX;
		targetLayer.frame().y = attrs.top  - offsetY;
	} else {
		targetLayer.frame().x = attrs.left - offsetX;
		targetLayer.frame().y = attrs.top  - offsetY;
	}
	targetLayer.frame().width = attrs.width;
	targetLayer.frame().height = attrs.height;
	// log( targetLayer.treeAsDictionary() );
	// log( '     finish setFrame() <-' );

	return targetLayer;
}

function setLayerName( targetLayer, name, type ) {
	name = unescape( name );
	if ( 'null' == name || '' == name ) {
		targetLayer.setName( type.replace(/^./g, type.charAt(0).toUpperCase() ) );
	} else {
		targetLayer.setName( name );
	}
}

function addStylePart( shape, type ) {
	return shape.style().addStylePartOfType( type );
}

function addPathAttributes( shape, attrs, maskMode ) {
	maskMode = maskMode || false;

	if ( null != attrs.fill ) {
		var fill = addStylePart( shape, 0 );

		if ( 'gradient' == attrs.fillType ) {
			addGradientFill( shape, attrs );
		} else if ( 'pattern' == attrs.fillType ) {
			addPatternFill( shape, attrs.fill.pattern.patternURI );
		} else {
			var color = MSColor.colorWithSVGString( getHexColor( attrs.fillColor ) );
			color.alpha = getOpacity( attrs.fillColor );
			fill.color = color;
		}
		if ( 'mask to path' == maskMode ) shape.style().fills().firstObject().isEnabled = false;
		if ( 'mask to image' == maskMode ) convertFilltoAlpha( shape, attrs.fillType );

		if ( 0 < attrs.fill.textureBlend && attrs.fillTexture.filePath && !maskMode ) {
			addTextureFill( shape, attrs );
		} else if ( 0 < attrs.fill.textureBlend && !maskMode ) {
			shape.name = unescape( shape.name() ) + ' [texture not found]';
		}
	}

	if ( null != attrs.brush ) {
		addBorder( shape, attrs );

		if ( 'mask to path' == maskMode ) shape.style().borders().firstObject().isEnabled = false;
	}
}

function addBorder( shape, attrs ) {
	var border = addStylePart( shape, 1 );
	var color = MSColor.colorWithSVGString( getHexColor( attrs.brushColor ) );
	color.alpha = getOpacity( attrs.brushColor );
	border.setColor( color );
	border.thickness = attrs.brush.diameter;
	switch ( attrs.brushPlacement ) {
		case 'center':
			border.setPosition( 0 );
			break; 
		case 'inside':
			border.setPosition( 1 );
			break; 
		case 'outside':
			border.setPosition( 2 );
			break; 
		default:
			border.setPosition( 0 );
			break; 
	}

	var borderOptions = shape.style();
	switch ( attrs.brush.shape ) {
		case 'square':
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
		case 'circle':
			borderOptions.borderOptions().setLineCapStyle( 1 );
			borderOptions.borderOptions().setLineJoinStyle( 1 );
			break; 
		default:
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
	}

	if ( 1 == attrs.brush.numDashes || 2 == attrs.brush.numDashes ) {
		var dashAttrs = [];
		var gapOffest = attrs.brush.shape == 'circle' ? attrs.brush.diameter : 0;
		for ( var i = 0; i < attrs.brush.numDashes; i++ ) {
			dashAttrs[i * 2] = attrs.brush['dashOnSize' + ( i + 1 )];
			dashAttrs[i * 2 + 1] = attrs.brush['dashOffSize' + ( i + 1 )] + gapOffest;
		}
		borderOptions.borderOptions().setDashPattern( dashAttrs );
	}
}

function addEffects( shape, attrs ) {
	for ( var i = attrs.length - 1; i >= 0; i-- ) {
		// log( '  Applied Effect: ' + attrs[i].name );

		if ( attrs[i].EffectIsVisible ) {
			switch ( attrs[i].name ) {
				case 'drop shadow':
					var effect = addStylePart( shape, 2 );
					effect.blurRadius = attrs[i].ShadowBlur;
					
					var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
					effect.offsetX = coord.x;
					effect.offsetY = coord.y;
					effect.spread = 0;

					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
					color.alpha = getOpacity( attrs[i].ShadowColor );
					effect.color = color;
					break;
				case 'inner shadow':
					var effect = addStylePart( shape, 3 );
					effect.blurRadius = attrs[i].ShadowBlur;
					
					var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
					effect.offsetX = coord.x;
					effect.offsetY = coord.y;
					effect.spread = 0;

					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
					color.alpha = getOpacity( attrs[i].ShadowColor );
					effect.color = color;
					break;
				case 'glow':
					switch( attrs[i].BevelType + '' ) {
						case '4':
							var effect = addStylePart( shape, 2 );
							effect.blurRadius = attrs[i].MaskSoftness;

							effect.offsetX = 0;
							effect.offsetY = 0;
							effect.spread = attrs[i].GlowWidth;

							var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
							color.alpha = attrs[i].BevelContrast / 100;
							effect.color = color;
							break;
					}
					break;
				case 'inner glow':
					var effect = addStylePart( shape, 3 );
					effect.blurRadius = attrs[i].MaskSoftness;
					
					effect.offsetX = 0;
					effect.offsetY = 0;
					effect.spread = attrs[i].GlowWidth;

					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
					color.alpha = attrs[i].BevelContrast / 100;
					effect.color = color;
					break;
				case 'solid shadow':
					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].color ) );
					color.alpha = 1;

					for ( var j = attrs[i].distance - 1; j >= 0; j-- ) {
						var effect = addStylePart( shape, 2 );
						effect.blurRadius = 0;
						
						var coord = getCoordfromTrigFunc( attrs[i].distance, attrs[i].angle );
						effect.offsetX = coord.x * (( j + 1 ) / attrs[i].distance );
						effect.offsetY = coord.y * (( j + 1 ) / attrs[i].distance );
						effect.spread = 0;

						effect.color = color;
					};
					break;
				case 'gaussian blur':
					var effect = shape.style().blur();
					effect.isEnabled = 1;
					effect.type = 0;
					effect.radius = attrs[i].gaussian_blur_radius;
					break;
				case 'motion blur':
					var effect = shape.style().blur();
					effect.isEnabled = 1;
					effect.type = 1;
					effect.radius = attrs[i].motion_blur_distance / 2;
					effect.motionAngle = attrs[i].motion_blur_angle;
					break;
				case 'zoom blur':
					var effect = shape.style().blur();
					effect.isEnabled = 1;
					effect.type = 2;
					effect.radius = attrs[i].zoom_blur_amount / 2;
					break;
				case 'add noise':
					var effect = addStylePart( shape, 0 );
					effect.fillType = 5;
					if ( attrs[i].add_noise_use_color ) {
						effect.noiseIndex = 3;
					} else {
						effect.noiseIndex = 2;
					}
					effect.contextSettings().blendMode = 9;
					effect.contextSettings().opacity = Math.round( attrs[i].add_noise_amount / 4 ) / 100;
					break;
				case 'color fill':
					var effect = addStylePart( shape, 0 );
					effect.setFillType(0);
					var color = MSColor.colorWithSVGString( getHexColor( attrs[i].Color ) );
					color.alpha = attrs[i].Opacity / 100;
					effect.contextSettings().blendMode = json2Layer.solidFill[attrs[i].Blendmode];
					effect.color = color;
					break;
				case 'photoshop live effects':
					// log( '  PsLE:' );
					for ( var j = json2Layer.PsLE.length - 1; j >= 0; j-- ) {
						// log( '    Flag: ' + json2Layer.PsLE[j] + ': ' + attrs[i][json2Layer.PsLE[j]].substring( 0, 1 ) );
						if( attrs[i][json2Layer.PsLE[j]] && '1' == attrs[i][json2Layer.PsLE[j]].substring( 0, 1 ) ) {
							// log( '      isEnabled:' );
							var psleAttrs = attrs[i][json2Layer.PsLE[j]].split( '&' );
							// log( '      psleAttrs:' );
							// log( psleAttrs );
							switch ( json2Layer.PsLE[j] ) {
								case 'satin':
									break;
								case 'dropShadow':
									var effect = addStylePart( shape, 2 );
									effect.blurRadius = psleAttrs[6];
									
									var coord = getCoordfromTrigFunc( psleAttrs[5], psleAttrs[3], true );
									effect.offsetX = coord.x;
									effect.offsetY = coord.y;
									effect.spread = psleAttrs[7];

									var originColor = psleAttrs[11].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									effect.color = color;
									break;
								case 'innerShadow':
									var effect = addStylePart( shape, 3 );
									effect.blurRadius = psleAttrs[6];
									
									var coord = getCoordfromTrigFunc( psleAttrs[5], psleAttrs[3], true );
									effect.offsetX = coord.x;
									effect.offsetY = coord.y;
									effect.spread = psleAttrs[7];

									var originColor = psleAttrs[11].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									effect.color = color;
									break;
								case 'outerGlow':
									var effect = addStylePart( shape, 2 );
									var subAttrs = psleAttrs[3].split( ':' );
									effect.blurRadius = subAttrs[2];
									
									effect.offsetX = 0;
									effect.offsetY = 0;
									effect.spread = subAttrs[1];

									var originColor = psleAttrs[5].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = subAttrs[0] / 100;
									effect.color = color;

									var blendMode = psleAttrs[2];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									break;
								case 'innerGlow':
									var effect = addStylePart( shape, 3 );
									var subAttrs = psleAttrs[3].split( ':' );
									effect.blurRadius = subAttrs[2];
									
									effect.offsetX = 0;
									effect.offsetY = 0;
									effect.spread = subAttrs[1];

									var originColor = psleAttrs[5].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = subAttrs[0] / 100;
									effect.color = color;
									
									var blendMode = psleAttrs[2];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									break;
								case 'solidFill':
									var effect = addStylePart( shape, 0 );
									effect.setFillType(0);
									var originColor = psleAttrs[3].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									var blendMode = psleAttrs[2];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									effect.color = color;
									break;
								case 'gradientFill':
									var effect = addStylePart( shape, 0 );
									effect.setFillType(1);
									// log( '      opacity: ' + ( psleAttrs[3] ) );
									// log( '      opacity: ' + ( psleAttrs[3] / 100 ) );
									effect.contextSettings().opacity = psleAttrs[3] / 100;
									var coord = getCoordfromTrigFunc( 1, psleAttrs[4], true );
									var coordStretch = ( Math.abs( coord.x ) > Math.abs( coord.y ) ) ? 1 / Math.abs( coord.x ) : 1 / Math.abs( coord.y );
									coord.x = coord.x * coordStretch;
									coord.y = coord.y * coordStretch;
									var startX = 0;
									var startY = 0;
									// offset coordinate
									if ( 0 > coord.x ) {
										startX = startX + Math.abs( coord.x );
										coord.x = 0;
									}
									if ( 0 > coord.y ) {
										startY = startY + Math.abs( coord.y );
										coord.y = 0;
									}
									effect.gradient().setPoint_atIndex_( CGPointMake( startX, startY ), 0 )
									effect.gradient().setPoint_atIndex_( CGPointMake( coord.x, coord.y ), 1 )
									break;
								case 'patternFill':
									break;
								case 'bevelEmboss':
									break;
								case 'stroke':
									var effect = addStylePart( shape, 1 );
									var originColor = psleAttrs[4].split( ';' );
									var color = MSColor.colorWithRGBADictionary( {
										r: bit2Percent( originColor[1] ), 
										g: bit2Percent( originColor[2] ), 
										b: bit2Percent( originColor[3] )
									} );
									color.alpha = psleAttrs[1] / 100;
									effect.color = color;
									effect.thickness = psleAttrs[2];
									var blendMode = psleAttrs[3];
									effect.contextSettings().blendMode = json2Layer.blendMode[blendMode];
									switch ( psleAttrs[5] ) {
										case 'centeredFrame':
											effect.setPosition( 0 );
											break; 
										case 'insetFrame':
											effect.setPosition( 1 );
											break; 
										case 'outsetFrame':
											effect.setPosition( 2 );
											break; 
										default:
											effect.setPosition( 0 );
											break; 
									}
									break;
							}
						}
					};
			}
		}
	};
}

function importBitmap( parent, attrs, isMask ) {
	var filePath = escape( attrs.uri );
	var splitPath = filePath.split( escape( json2Layer.resPath.exportedDir ) );
	filePath = json2Layer.resPath.basePath + '/' + json2Layer.resPath.exportedDir + splitPath[1];

	var imageData = NSImage.new().initWithContentsOfFile( filePath );
	var bitmap = MSBitmapLayer.new();
	bitmap.image = imageData;
	// log( filePath.toString() )
	// log( bitmap );
	bitmap = setFrame( bitmap, attrs, ( isMask ? parent : false ) );
	bitmap.name = unescape( attrs.name );

	parent.addLayers( [bitmap] );

	return bitmap;
}

function createMask( parent, attrs ) {
	// log( '    -> createMask' );

	var maskGroup = createGroup( parent, attrs );
	var mask = createElements( maskGroup, attrs.mask.element, attrs.mask.mode );
	// log( '     Mask Object: ' + mask.frame() );

	mask.setHasClippingMask( true );

	if ( 'mask to path' == attrs.mask.mode ) {
		mask.clippingMaskMode = 0; // Outline
	} else {
		mask.clippingMaskMode = 1; // Alpha
	}

	return maskGroup;
}

function createGroup( parent, attrs, _isLayer ) {
	// log( '    -> createGroup' );

	var isLayer = _isLayer || false;	
	// var group = parent.addLayerOfType( 'group' );
	var group = MSLayerGroup.new();
	setLayerName( group, attrs.name, 'group' );
	group.hasClickThrough = ( isLayer ) ? 1 : 0;
	parent.addLayers( [group] );

	return group;
}

function createText( parent, attrs, isMask ) {
	var text = MSTextLayer.new();
	parent.addLayers( [text] );
	if ( !attrs.autoExpand ) text.textBehaviour = 1;

	var textPart = [0];
	var textPartNum = attrs.textRuns.length;
	text.stringValue = '';
	for ( var i = 0; i < textPartNum; i++ ) {
		// log( unescape( attrs.textRuns[i].characters ) + attrs.textRuns[i].characters );
		text.stringValue = text.stringValue() + unescape( attrs.textRuns[i].characters );
		textPart.push( textPart[i] + unescape( attrs.textRuns[i].characters ).length );
	}

	text.usesNewLineSpacingBehaviour = 1;
	if ( 1 < textPartNum ) {
		for ( var i = 0; i < textPartNum; i++ ) {
			var range = NSMakeRange( textPart[i], textPart[i + 1] - textPart[i] );
			var textFont = NSFont.fontWithName_size_( attrs.textRuns[i].face, attrs.textRuns[i].size );
			var color = hex2Color( attrs.textRuns[i].fillColor );
			var pragraph = NSMutableParagraphStyle.new()
			pragraph.minimumLineHeight = attrs.textRuns[i].leading;
			pragraph.maximumLineHeight = attrs.textRuns[i].leading;

			text.setIsEditingText( true );
			text.addAttribute_value_forRange_( NSFontAttributeName, textFont, range );
			text.addAttribute_value_forRange_( NSForegroundColorAttributeName, color, range );
			text.addAttribute_value_forRange_( NSParagraphStyleAttributeName, pragraph, range );
			text.setIsEditingText( false );
		}
	} else {
		text.fontSize           = attrs.fontSize;
		text.fontPostscriptName = attrs.fontFace;
		text.textColor          = MSColor.colorWithSVGString( attrs.fillColor );

		var pragraph = NSMutableParagraphStyle.new()
		pragraph.minimumLineHeight = attrs.leading;
		pragraph.maximumLineHeight = attrs.leading;
		text.addAttribute_value_( NSParagraphStyleAttributeName, pragraph );
	}
	text = setFrame( text, attrs, ( isMask ? parent : false ) );
	text.adjustFrameToFit();
	
	switch ( attrs.alignment ) {
		case 'left':
			text.setTextAlignment( 0 );
			break;
		case 'right':
			text.setTextAlignment( 1 );
			break;
		case 'center':
			text.setTextAlignment( 2 );
			break;
		default:
			text.setTextAlignment( 0 );
			break;
	}

	applyRotation( text, attrs.transform.matrix[3] );
	
	return text;
}

function createRectangle( parent, attrs, isMask ) {
	var originMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	var isTransformed = false;
	
	for (var i = 0; i < originMatrix.length; i++) {
		if ( originMatrix[i] != attrs.transform.matrix[i] && ( 0 != i && 4 != i && 6 != i && 7 != i) ) {
			isTransformed = true;
			break;
		}
	}
	var m = attrs.transform.matrix;
	var ow = attrs.originalSides['right']  - attrs.originalSides['left'],
	    oh = attrs.originalSides['bottom'] - attrs.originalSides['top'];
	var ol = attrs.originalSides['left'],
	    ot = attrs.originalSides['top'],
	    ob = attrs.originalSides['bottom'],
	    or = attrs.originalSides['right'];
	var bounds = [
		attrs.left,               attrs.top,
		attrs.left + attrs.width, attrs.top,
		attrs.left + attrs.width, attrs.top + attrs.height,
		attrs.left,               attrs.top + attrs.height
	];

	if ( isTransformed ) {
		var rectangle = NSBezierPath.bezierPath();

		// a d g b e h c f i
		// 0 1 2 3 4 5 6 7 8
		// u = (x*a + y*b + c) / (x*g + y*h + 1)
		// v = (x*d + y*e + f) / (x*g + y*h + 1)
		// X1 = x1 * a + y1 * b + c − x1 * g * X1 − y1 * h * X1
		// Y1 = x1 * d + y1 * e + f − x1 * g * Y1 − y1 * h * Y1

		var vector = [];
		vector.push(( ol * m[0] + ot * m[3] + m[6] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( ol * m[1] + ot * m[4] + m[7] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( or * m[0] + ot * m[3] + m[6] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( or * m[1] + ot * m[4] + m[7] ) / ( or * m[2] + ot * m[5] + m[8] ));
		vector.push(( or * m[0] + ob * m[3] + m[6] ) / ( or * m[2] + ob * m[5] + m[8] ));
		vector.push(( or * m[1] + ob * m[4] + m[7] ) / ( or * m[2] + ob * m[5] + m[8] ));
		vector.push(( ol * m[0] + ob * m[3] + m[6] ) / ( ol * m[2] + ob * m[5] + m[8] ));
		vector.push(( ol * m[1] + ob * m[4] + m[7] ) / ( ol * m[2] + ob * m[5] + m[8] ));

		var matrix = [];
		matrix.push( ol * m[0] + ot * m[3] + m[6] - ol * m[2] * vector[0] - ot * m[5] * vector[0] );
		matrix.push( ol * m[1] + ot * m[4] + m[7] - ol * m[2] * vector[1] - ot * m[5] * vector[1] );
		matrix.push( or * m[0] + ot * m[3] + m[6] - or * m[2] * vector[2] - ot * m[5] * vector[2] );
		matrix.push( or * m[1] + ot * m[4] + m[7] - or * m[2] * vector[3] - ot * m[5] * vector[3] );
		matrix.push( or * m[0] + ob * m[3] + m[6] - or * m[2] * vector[4] - ob * m[5] * vector[4] );
		matrix.push( or * m[1] + ob * m[4] + m[7] - or * m[2] * vector[5] - ob * m[5] * vector[5] );
		matrix.push( ol * m[0] + ob * m[3] + m[6] - ol * m[2] * vector[6] - ob * m[5] * vector[6] );
		matrix.push( ol * m[1] + ob * m[4] + m[7] - ol * m[2] * vector[7] - ob * m[5] * vector[7] );

		rectangle.moveToPoint( NSMakePoint( matrix[0] / m[8], matrix[1] / m[8] ));
		rectangle.lineToPoint( NSMakePoint( matrix[2] / m[8], matrix[3] / m[8] ));
		rectangle.lineToPoint( NSMakePoint( matrix[4] / m[8], matrix[5] / m[8] ));
		rectangle.lineToPoint( NSMakePoint( matrix[6] / m[8], matrix[7] / m[8] ));
		rectangle.closePath();

		var shape = MSShapeGroup.shapeWithBezierPath( rectangle );
		for (var i = 0; i < shape.layers().firstObject().path().points().count(); i++) {
			shape.layers().firstObject().path().points().objectAtIndex( i ).setCornerRadius( attrs.radius * m[8] );
		}
		parent.addLayers( [shape] );
	} else {
		var rectangle = MSRectangleShape.new();
		rectangle.frame().width = attrs.width;
		rectangle.frame().height = attrs.height;
		var shape = MSShapeGroup.shapeWithPath( rectangle );
		var offsetX = ( 'MSLayerGroup' == parent.class() ) ? parent.frame().x() : 0;
		var offsetY = ( 'MSLayerGroup' == parent.class() ) ? parent.frame().y() : 0;
		shape.frame().x = attrs.left - offsetX;
		shape.frame().y = attrs.top - offsetY;
		parent.addLayers( [shape] );
		shape.layers().firstObject().cornerRadiusFloat = attrs.radius * m[0];
	}
	// parent.addLayers( [shape] );

	return shape;
}

function createSlice( parent, attrs, isMask ) {
	var slice = MSSliceLayer.new();
	slice = setFrame( slice, attrs, ( isMask ? parent : false ) );
	setLayerName( slice, attrs.baseName, 'slice' );

	parent.addLayers( [slice] );

	return slice;
}

function addBezier( parent, attrs, isMask ) {
	var bezierLine = NSBezierPath.bezierPath();
	// log( '     -> addBezier Parent Frame' );
	var offsetX = 0;
	var offsetY = 0;

	for ( var i = 0; i < attrs.length; i ++ ) {
		var nodes = attrs[i].nodes;
		bezierLine.moveToPoint( NSMakePoint( nodes[0].x, nodes[0].y ) );

		for ( var j = 1; j < nodes.length; j++ ) {
			var ancher        = NSMakePoint( nodes[j].x,         nodes[j].y );
			var currentHandle = NSMakePoint( nodes[j].predX,     nodes[j].predY );
			var prevHandle    = NSMakePoint( nodes[j - 1].succX, nodes[j - 1].succY );
			// log( 'ancher:        ' + ancher );
			// log( 'currentHandle: ' + currentHandle );
			// log( 'prevHandle:    ' + prevHandle );
			[bezierLine curveToPoint:ancher controlPoint1:prevHandle controlPoint2:currentHandle];
		};
		if ( attrs[i].isClosed ) {
			[bezierLine 
				curveToPoint: NSMakePoint( nodes[0].x,                    nodes[0].y ) 
				controlPoint1:NSMakePoint( nodes[nodes.length - 1].succX, nodes[nodes.length - 1].succY )
				controlPoint2:NSMakePoint( nodes[0].predX,                nodes[0].predY )
			];
			bezierLine.closePath();
		}
	}
	var shape = MSShapeGroup.shapeWithBezierPath( bezierLine );

	return shape;
}

function createSymbol( parent, attrs ) {
	// log( '           Create Symbol' );

	var shape = createGroup( parent, attrs );
	setLayerName( shape, attrs.symbolName, 'symbol' );
	addContextSettings( shape, attrs );
	createElements( shape, json2Layer.orgSymbols[attrs.elements].elements );
	shape.resizeToFitChildrenWithOption( false );

	var symbols = json2Layer.doc.documentData().layerSymbols();
	symbols.addSymbolWithName_firstInstance( attrs.symbolName, shape );

	var shape = parent.layers().objectAtIndex( parent.layers().count() - 1 );
	shape.frame().x = attrs.left;
	shape.frame().y = attrs.top;

	json2Layer.symbols.push( 
		{ 
			fwSymbolID: attrs.symbolID,
			width: attrs.width, 
			height: attrs.height,
			symbolID: shape.sharedObjectID()
		}
	);

	return shape;
}

function addSymbol( parent, attrs, symbolIndex ) {
	// log( '           Exist Symbol' );
	var symbol = json2Layer.doc.documentData().layerSymbols().symbolAtIndex( symbolIndex );
	var shape = symbol.newInstance();
	shape.setName( unescape( attrs.name ));
	shape.frame().x = attrs.left;
	shape.frame().y = attrs.top;
	parent.addLayers( [shape] );
	// doc.reloadInspector();

	return shape;
}

function setGrid( artboard, gridAttrs ) {
	if( 'MSArtboardGroup' == artboard.class() ) {
		var grid = MSSimpleGrid.new();
		grid.setGridSize( ( gridAttrs.gridSize.x ) ? gridAttrs.gridSize.x : 10 );
		artboard.grid = grid;
	}
}

function addGuideline ( parent, guides, grid ) {
	var vRuler = parent.verticalRulerData();
	var hRuler = parent.horizontalRulerData();

	// set origin
	hRuler.setBase( grid.x );
	vRuler.setBase( grid.y );

	// set guidelines
	for ( var i in guides.x ) {
		hRuler.addGuideWithValue( guides.x[i] );
	}
	for ( var i in guides.y ) {
		vRuler.addGuideWithValue( guides.y[i] );
	}
}

function addTextureFill( shape, attrs ) {
	// log( '     -> addTextureFill' );
	var splitPath = attrs.fillTexture.filePath.split( json2Layer.resPath.exportedDir);
	var filePath = json2Layer.resPath.basePath + '/' + json2Layer.resPath.exportedDir + splitPath[1];
	var image = NSImage.new().initWithContentsOfFile( filePath );
	var shapeFill = addStylePart( shape, 0 );
	
	shapeFill.setFillType( 4 );
	shapeFill.setPatternFillType( 0 );

	var imageData = MSImageData.new().initWithImage_convertColorSpace_( image, false );
	shapeFill.setImage( imageData );

	var contextSettings = shapeFill.contextSettings();
	contextSettings.opacity = attrs.fill.textureBlend / 100;
	contextSettings.blendMode = json2Layer.blendMode['screen'];
}

function addPatternFill( shape, attrs ) {
	// log( '     -> addPatternFill' );
	var splitPath = attrs.split( json2Layer.resPath.exportedDir );
	var filePath = json2Layer.resPath.basePath + '/' + json2Layer.resPath.exportedDir + splitPath[1];
	var image = NSImage.new().initWithContentsOfFile( filePath );
	var shapeStyle = shape.style();
	var shapeFill = shapeStyle.fill();
	
	shapeFill.setFillType( 4 );
	shapeFill.setPatternFillType( 1 );

	var imageData = MSImageData.new().initWithImage_convertColorSpace_( image, false );
	shapeFill.setImage( imageData );
}

function addGradientFill( shape, pathAttrs ) {
	// log( '>>> addGradientFill: ' + pathAttrs.fill.gradient.gradientType );

	var attrs = pathAttrs.fill.gradient;
	var gradientNodes = attrs.nodes.concat( attrs.opacityNodes );

	// sort gradient stops by position
	for ( var i = 0; i < gradientNodes.length - 1; i++ ) {
		for ( var j = gradientNodes.length - 1; j > i; j-- ) {
			if ( gradientNodes[j - 1].position > gradientNodes[j].position ) {
				var exchenge = gradientNodes[j - 1];
				gradientNodes[j - 1] = gradientNodes[j];
				gradientNodes[j] = exchenge;
			}
		};
	};
	// log( 'gradientNodes' );
	// log( gradientNodes );


	var ci = 0, // color index
	    oi = 0; // opacityNodes index
	var optimazedPoints = [];
	for ( var i = 0, index = 0; i < gradientNodes.length; i++ ) {
		optimazedPoints[index] = {};
		if ( gradientNodes.length == i + 1 ) {
			optimazedPoints[index].position = gradientNodes[i].position;
			if ( gradientNodes[i].isOpacityNode ) {
				optimazedPoints[index].opacity  = getOpacityByDigit( gradientNodes[i].color.slice( 7, 9 ) );
				optimazedPoints[index].color = optimazedPoints[index - 1].color;
			} else {
				optimazedPoints[index].opacity  = optimazedPoints[index - 1].opacity;
				optimazedPoints[index].color    = gradientNodes[i].color;
			}
		} else if ( gradientNodes[i].position < gradientNodes[i + 1].position ) {
			if ( gradientNodes[i].isOpacityNode ) {
				optimazedPoints[index].position = gradientNodes[i].position;
				optimazedPoints[index].opacity  = getOpacityByDigit( gradientNodes[i].color.slice( 7, 9 ) );
				if ( 0 == ci || gradientNodes.length == i + 1 ) {
					optimazedPoints[index].color = attrs.nodes[ci].color;
				} else {
					var nodeColor;
					var assets = {prev:{}, next:{}, current:{}};
						assets.prev.position    = attrs.nodes[ci - 1].position;
						assets.prev.color       = attrs.nodes[ci - 1].color;
						assets.next.position    = attrs.nodes[ci].position;
						assets.next.color       = attrs.nodes[ci].color;
						assets.current.position = optimazedPoints[index].position;

					optimazedPoints[index].color = getGradientStopColorOnOpacitySide( assets );
				}
				index++;
				oi++;
			} else {
				optimazedPoints[index].color    = gradientNodes[i].color;
				optimazedPoints[index].position = gradientNodes[i].position;
				if ( 0 == oi || gradientNodes.length == i + 1 ) {
					var nodeOpacity = attrs.opacityNodes[ci].color.slice( 7, 9 );
					optimazedPoints[index].opacity  = getOpacityByDigit( nodeOpacity );
				} else {
					var nodeOpacity;
					var assets = {prev:{}, next:{}, current:{}};
						assets.prev.position = attrs.opacityNodes[oi - 1].position;
						nodeOpacity          = attrs.opacityNodes[oi - 1].color.slice( 7, 9 );
						assets.prev.opacity  = getOpacityByDigit( nodeOpacity );
						assets.next.position = attrs.opacityNodes[oi].position;
						nodeOpacity          = attrs.opacityNodes[oi].color.slice( 7, 9 );
						assets.next.opacity  = getOpacityByDigit( nodeOpacity );
						assets.current.position = optimazedPoints[index].position;

					optimazedPoints[index].opacity = getGradientOpacity( assets );
				}
				index++;
				ci++;
			}

		} else if ( gradientNodes[i].position == gradientNodes[i + 1].position ) {
			optimazedPoints[index].color    = gradientNodes[i].color;
			optimazedPoints[index].position = gradientNodes[i].position;
			optimazedPoints[index].opacity  = getOpacityByDigit( gradientNodes[i + 1].color.slice( 7, 9 ) );
			index++;
			i++;
			ci++;
			oi++;
		}
	}

	var shapeStyle = shape.style();
	// shapeStyle.fills().addNewStylePart();
	var shapeFill = shapeStyle.fill();
	shapeFill.setFillType( 1 ); // gradient fill

	var gradient = shapeFill.gradient();
	switch ( attrs.gradientType ) {
		case 'linear':
			gradient.setGradientType( 0 );
			break;
		case 'radial':
		case 'elliptical':
			gradient.setGradientType( 1 );
			break;
		case 'conical':
			gradient.setGradientType( 2 );
			break;
		default:
			gradient.setGradientType( 0 );
			break;
	}

	var orignPoint = optimazedPoints.length;
	for ( var i = 0; i < orignPoint; i++ ) {
		if ( 0 != optimazedPoints[i].position && 1 != optimazedPoints[i].position ) {
			gradient.addStopAtLength( roundWithDigit( optimazedPoints[i].position, 2 ) );
		}
	}
	for ( var i = 0; i < orignPoint; i++ ) {
		var gradientColor = MSColor.colorWithSVGString( optimazedPoints[i].color );
		gradientColor.alpha = optimazedPoints[i].opacity;
		gradient.setColor_atIndex_( gradientColor, i );
	}

	var shapeX = shape.frame().x();
	var shapeY = shape.frame().y();
	var shapeW = shape.frame().width();
	var shapeH = shape.frame().height();
	var startX = ( pathAttrs.fillHandle1.x - shapeX ) / shapeW;
	var startY = ( pathAttrs.fillHandle1.y - shapeY ) / shapeH;
	var endX = ( pathAttrs.fillHandle2.x - shapeX ) / shapeW;
	var endY = ( pathAttrs.fillHandle2.y - shapeY ) / shapeH;
	if ( 'elliptical' == attrs.gradientType ) {
		var handlePoint1x = pathAttrs.fillHandle2.x - pathAttrs.fillHandle1.x;
		var handlePoint1y = pathAttrs.fillHandle2.y - pathAttrs.fillHandle1.y;
		if ( 0 != handlePoint1x && 0 != handlePoint1y ) {
			var handle1Length = Math.sqrt( handlePoint1x * handlePoint1x + handlePoint2y * handlePoint2y );
		} else {
			var handle1Length = ( 0 != handlePoint1x ) ? handlePoint1x : handlePoint1y;
		}
		var handlePoint2x = pathAttrs.fillHandle3.x - pathAttrs.fillHandle1.x;
		var handlePoint2y = pathAttrs.fillHandle3.y - pathAttrs.fillHandle1.y;
		if ( 0 != handlePoint2x && 0 != handlePoint2y ) {
			var handle2Length = Math.sqrt( handlePoint2x * handlePoint2x + handlePoint2y * handlePoint2y );
		} else {
			var handle2Length = ( 0 != handlePoint2x ) ? handlePoint2x : handlePoint2y;
		}
		gradient.elipseLength = Math.abs( handle2Length / handle1Length );
	}
	if ( 'conical' != attrs.gradientType ) {
		gradient.from = CGPointMake( startX, startY );
		gradient.setPoint_atIndex_( CGPointMake( startX, startY ), 0 );
		gradient.setPoint_atIndex_( CGPointMake( endX, endY ), orignPoint - 1 );
	} else {
		for ( var i = 0; i < gradient.stops().count(); i++ ) {
			gradient.stops().objectAtIndex( i ).position = gradient.stops().objectAtIndex( i ).position() / 2;
		}
		var originalStops = gradient.stops().count();
		for ( var i = 0; i < originalStops; i++ ) {
			if ( 0 != gradient.stops().objectAtIndex( i ).position() 
				 && 0.5 != gradient.stops().objectAtIndex( i ).position() ) {
				gradient.addStopAtLength( 1 - gradient.stops().objectAtIndex( i ).position() );
				gradient.setColor_atIndex_( gradient.stops().objectAtIndex( i ).color(), gradient.stops().count() - 1 );
			}
		}
	}
}

function convertFilltoAlpha( shape, fillType ) {
	switch ( fillType ) {
		case 'gradient':
			var gradient = shape.style().fills().firstObject().gradient();
			for ( var i = 0; i < gradient.stops().count(); i++ ) {
				var color = MSColor.colorWithSVGString( '#' + gradient.stops().objectAtIndex(i).color().hexValue().toString() );
				color.alpha = gradient.stops().objectAtIndex(i).color().alpha() * gray2Alpha( gradient.stops().objectAtIndex(i).color().hexValue().toString() );
				gradient.setColor_atIndex_( color, i );
			}
			break;
		case 'flat':
			var fill = shape.style().fills().firstObject();
			var color = MSColor.colorWithSVGString( '#' + fill.color().hexValue().toString() );
			color.alpha = gray2Alpha( fill.color().hexValue().toString() );
			fill.setFillType( 1 );
			var gradient = fill.gradient();
			for ( var i = 0; i < fill.gradient().stops().count(); i++ ) {
				gradient.setColor_atIndex_( color, i );
			}
			break;
	}
}

function applyRotation( shape, radian ) {
	var angle = roundWithDigit( 0 - radian * ( 180 / Math.PI ), 2 );
	if ( 0 != angle ) {
		angle = 360 - angle;
		shape.rotation = angle;
	}
}
