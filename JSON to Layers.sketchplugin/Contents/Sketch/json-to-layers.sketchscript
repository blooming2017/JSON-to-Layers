@import 'lib/const.js';

var onRun = function ( context ) {
	log( '------------------------------------------------------------' );
	var doc = context.document;
	var currentPage = doc.currentPage();

	var userJSON = [doc askForUserInput:"Paste your JSON here:" initialValue:""];
	if ( !userJSON ) return false;
	var json = userJSON;
	// var fwJSON = JSON.parse( json );
	var fwJSON = ( new Function( 'return ' + json ) )();

	var artboardPosition = 0; 
	for ( var i = 0; i < fwJSON.pages.length; i++ ) {
		var artboard = MSArtboardGroup.new();
		artboard.setName( fwJSON.pages[i].pageName );
		artboard.frame().setX( artboardPosition );
		artboard.frame().setY( 0 );
		artboard.frame().setWidth( fwJSON.pages[i].width );
		artboard.frame().setHeight( fwJSON.pages[i].height );
		// doc.addLayer( artboard );
		currentPage.addLayers( NSArray.arrayWithObjects( artboard ) );
		var artboards = doc.currentPage().artboards();

		setGrid( artboards[i], fwJSON.documentSetting.grid );
		addGuideline( artboards[i], fwJSON.pages[i].guides, fwJSON.documentSetting.grid.gridOrigin );
		createLayers( artboards[i], fwJSON.pages[i].layers );
		// log( fwJSON.pages[i].width );

		artboardPosition += fwJSON.pages[i].width + 100;
	}

}

function createLayers( artboard, layers ) {
	var layerGroups = [];
	for ( var i = 0; i < layers.length; i++ ) {
		log( 'Layer: ' + layers[i].layerName );
		if ( 0 > layers[i].parentLayerNum ) {
			var parent = artboard;
		} else {
			var parent = layerGroups[layers[i].parentLayerNum];
		}
		log( 'Parent Layer:' + parent.name() );
		if ( layers[i].hasChildren ) {
			layerGroups[i] = createGroup( parent, layers[i], true );
			var bounds = createElements( layerGroups[i], layers[i].elems );
		}
	}
}

function createElements( parent, elems, isMask ) {
	log( '-> Child Layer Proccessing' );
	if ( !isMask ) isMask = false;
	var shape;
	var layers = [];
	for (var i = elems.length - 1; i >= 0; i--) {
		log( '-> Proccessing: ' + elems[i].name );
		var elemsType = elems[i].type;
		if ( 'text' == elemsType ) {
			log( 'Type: Text' );
			var shape = createText( parent, elems[i] );
			shape.setName( elems[i].name );
		}
		if ( 'bitmap' == elemsType ) {
			log( 'Type: Bitmap' );
			if ( null != elems[i].mask ) {
				log( 'Has Mask' );
				parent = createMask( parent, elems[i] );
			}
			var shape = importBitmap( parent, elems[i] );
			addContextSettings( shape, elems[i] );
		}
		if ( 'rectangle' == elemsType ) {
			log( 'Type: Rectangle' );
			if ( null != elems[i].mask ) {
				log( 'Has Mask' );
				parent = createMask( parent, elems[i] );
			}
			var shape = createRectangle( parent, elems[i] );
			shape.setName( elems[i].name );
			addContextSettings( shape, elems[i] );
			// artboard.addLayers( [shape] );
			if ( null != elems[i].fill && !isMask ) {
				addFill( shape, elems[i].fill );
			}
			if ( null != elems[i].border && !isMask ) {
				addBorder( shape, elems[i].border );
			}
		}
		if ( 'path' == elemsType ) {
			log( 'Type: Bezier Path' );
			if ( null != elems[i].mask ) {
				log( 'Has Mask' );
				parent = createMask( parent, elems[i] );
			}
			var shape = addBezier( parent, elems[i].bezierPath );
			shape.setName( elems[i].name );
			addContextSettings( shape, elems[i] );
			parent.addLayers( [shape] );
			if ( null != elems[i].fill && !isMask ) {
				addFill( shape, elems[i].fill );
			}
			if ( null != elems[i].border && !isMask ) {
				addBorder( shape, elems[i].border );
			}
		}
		if ( 'slice' == elemsType ) {
			log( 'Type: Slice' );
			var shape = createSlice( parent, elems[i] );
			// shape.setName( elems[i].name );
		}
		if ( 'layer group' == elemsType ) {
			log( 'Type: Layer Group' );
			shape = createGroup( parent, elems[i] );
			addContextSettings( shape, elems[i] );
			var bounds = createElements( shape, elems[i].elements );
			parent.frame().x = bounds.origin.x;
			parent.frame().y = bounds.origin.y;
		}
		if ( 'symbol' == elemsType ) {
			log( 'Type: Layer Group' );
			shape = createGroup( parent, elems[i] );
			addContextSettings( shape, elems[i] );
			var bounds = createElements( shape, elems[i].elements );
			shape.frame().x = bounds.origin.x;
			shape.frame().y = bounds.origin.y;
		}
		if ( null != elems[i].effectList ) {
			addEffects( shape, elems[i].effectList.effects );
		}
		if ( null != elems[i].mask ) {
			// parent.resizeRoot( true );
		}

		layers.push( shape );
	};
	// parent.resizeRoot( true );
	log( '!!! Finished createElements !!!');
	log( '!!! resizeRoot()');
	parent.resizeRoot( true );

	return MSLayerGroup.groupBoundsForLayers( layers );
}

function addContextSettings( shape, attrs ) {
	var contextSettings = shape.style().contextSettings();
	contextSettings.opacity = Math.round( attrs.opacity ) / 100;
	if ( fw2json.blendMode[attrs.blendMode] ) {
		contextSettings.blendMode = fw2json.blendMode[attrs.blendMode];
	}
}

function setFrame( targetLayer, attrs, parent ) {
	targetLayer.frame().x = attrs.left - parent.absoluteRect().x();
	targetLayer.frame().y = attrs.top - parent.absoluteRect().y();
	targetLayer.frame().width = attrs.width;
	targetLayer.frame().height = attrs.height;

	return targetLayer;
}

function addFill( shape, attrs ) {
	var fill = shape.style().fills().addNewStylePart();
	
	if( 'gradient' == attrs.fillType ) {
		addGradientFill( shape, attrs.gradient );
	} else if ( 'pattern' == attrs.fillType ) {
		addPatternFill( shape, attrs.pattern );
	} else {
		var color = MSColor.colorWithSVGString( getHexColor( attrs.fillColor ) );
		color.alpha = getOpacity( attrs.fillColor );
		fill.color = color;
	}
}

function addBorder( shape, attrs ) {
	var border = shape.style().borders().addNewStylePart();
	var color = MSColor.colorWithSVGString( attrs.color );
	color.alpha = attrs.opacity;
	border.color = color;
	border.thickness = attrs.thickness;
	switch ( attrs.position ) {
		case 'center':
			border.setPosition( 0 );
			break; 
		case 'inside':
			border.setPosition( 1 );
			break; 
		case 'outside':
			border.setPosition( 2 );
			break; 
		default:
			border.setPosition( 0 );
			break; 
	}

	var borderOptions = shape.style();
	switch ( attrs.edge ) {
		case 'square':
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
		case 'circle':
			borderOptions.borderOptions().setLineCapStyle( 1 );
			borderOptions.borderOptions().setLineJoinStyle( 1 );
			break; 
		default:
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
	}

	if ( 1 == attrs.dashType || 2 == attrs.dashType ) {
		var dashAttrs = [];
		var gapOffest = attrs.edge == 'circle' ? attrs.thickness : 0;
		for ( var i = 0; i < attrs.dashType; i++ ) {
			dashAttrs[i * 2] = attrs.dashAttr[i].dash;
			dashAttrs[i * 2 + 1] = attrs.dashAttr[i].gap + gapOffest;
		}
		borderOptions.borderOptions().setDashPattern( dashAttrs );
	}
}

function addEffects( shape, attrs ) {
	for ( var i = attrs.length - 1; i >= 0; i-- ) {
		if ( 'ドロップシャドウ' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().shadows().addNewStylePart();
			effect.blurRadius = attrs[i].ShadowBlur;
			
			var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
			effect.offsetX = coord.x;
			effect.offsetY = coord.y;
			effect.spread = 0;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
			color.alpha = getOpacity( attrs[i].ShadowColor );
			effect.color = color;
		}
		if ( 'シャドウ (内側)' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().innerShadows().addNewStylePart();
			effect.blurRadius = attrs[i].ShadowBlur;
			
			var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
			effect.offsetX = coord.x;
			effect.offsetY = coord.y;
			effect.spread = 0;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
			color.alpha = getOpacity( attrs[i].ShadowColor );
			effect.color = color;
		}
		if ( 'グロー' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().shadows().addNewStylePart();
			effect.blurRadius = attrs[i].MaskSoftness;

			effect.offsetX = 0;
			effect.offsetY = 0;
			effect.spread = attrs[i].GlowWidth;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
			color.alpha = attrs[i].BevelContrast / 100;
			effect.color = color;
		}
		if ( '光彩 (内側)' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().innerShadows().addNewStylePart();
			effect.blurRadius = attrs[i].MaskSoftness;
			
			effect.offsetX = 0;
			effect.offsetY = 0;
			effect.spread = attrs[i].GlowWidth;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
			color.alpha = attrs[i].BevelContrast / 100;
			effect.color = color;
		}
		if ( 'ソリッドシャドウ…' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].color ) );
			color.alpha = 1;

			for ( var j = attrs[i].distance - 1; j >= 0; j-- ) {
				var effect = shape.style().shadows().addNewStylePart();
				effect.blurRadius = 0;
				
				var coord = getCoordfromTrigFunc( j, attrs[i].angle );
				effect.offsetX = coord.x;
				effect.offsetY = coord.y;
				effect.spread = 0;

				effect.color = color;
			};
		}
		if ( 'ぼかし (ガウス)...' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().blur();
			effect.isEnabled = 1;
			effect.type = 0;
			effect.radius = attrs[i].gaussian_blur_radius;
		}
	};
}

function importBitmap( parent, attrs ) {
	var filePath = attrs.uri;
	filePath = filePath.replace( "file:///Macintosh%20HD/", "/" );

	var bitmap = MSBitmapLayer.bitmapLayerWithImageFromPath( filePath.toString() );
	bitmap = setFrame( bitmap, attrs, parent );
	bitmap.name = attrs.name;

	parent.addLayers( [bitmap] );

	return bitmap;
}

function createMask( parent, attrs ) {
	log( '/ createMask' );
	log( attrs );
	var maskGroup = parent.addLayerOfType( 'group' );
	maskGroup.setName( attrs.name );
	var mask = createElements( maskGroup, attrs.mask.element, true );
	log( 'Mask Object: ' + mask.frame() );
	mask.setHasClippingMask( true );
	log( '!!! resizeRoot()');
	mask.resizeRoot( true );

	return maskGroup;
}

function createGroup( parent, attrs, _isLayer ) {
	var isLayer = _isLayer || false;
	var group = parent.addLayerOfType( 'group' );
	group.setName( attrs.layerName || attrs.name );
	group.hasClickThrough = ( isLayer ) ? 1 : 0;

	return group;
}

function createText( artboard, attrs ) {
	var text = artboard.addLayerOfType( 'text' );
	text = setFrame( text, attrs, artboard );

	var textPart = [0];
	var textPartNum = attrs.text.textRuns.length;
	text.stringValue = '';
	for ( var i = 0; i < textPartNum; i++ ) {
		text.stringValue = text.stringValue() + attrs.text.textRuns[i].characters;
		textPart.push( textPart[i] + attrs.text.textRuns[i].characters.length );
	}

	if ( 1 < textPartNum ) {
		for ( var i = 0; i < textPartNum; i++ ) {
			var range = NSMakeRange( textPart[i], textPart[i + 1] - textPart[i] );
			var textFont = NSFont.fontWithName_size_( attrs.text.textRuns[i].face, attrs.text.textRuns[i].size );

			text.setIsEditingText( true );
			text.addAttribute_value_forRange( NSFontAttributeName, textFont, range );
			text.setIsEditingText( false );
		}
	} else {
		text.fontSize           = attrs.text.fontSize;
		text.lineSpacing        = attrs.text.leading;
		text.fontPostscriptName = attrs.text.fontFace;
		text.textColor          = MSColor.colorWithSVGString( attrs.text.fillColor );
	}
	
	switch ( attrs.text.alignment ) {
		case 'left':
			text.setTextAlignment( 0 );
			break;
		case 'right':
			text.setTextAlignment( 1 );
			break;
		case 'center':
			text.setTextAlignment( 2 );
			break;
		default:
			text.setTextAlignment( 0 );
			break;
	}
	
	return text;
}

function createRectangle( artboard, attrs ) {
	var rectangle = MSRectangleShape.new();

	rectangle = setFrame( rectangle, attrs, artboard );

	var shape = MSShapeGroup.shapeWithPath( rectangle );
	shape.layers().firstObject().cornerRadiusFloat = attrs.radius;
	// shape.layers().firstObject().cornerRadiusString = "7/0/0/10";
	artboard.addLayers( [shape] );

	return shape;
}

function createSlice( artboard, attrs ) {
	var slice = MSSliceLayer.new();
	slice = setFrame( slice, attrs, artboard );
	slice.setName( attrs.name );

	artboard.addSlice( slice );
}

function addBezier( artboard, attrs ) {
	var bezierLine = NSBezierPath.bezierPath();

	for ( var i = 0; i < attrs.length; i ++ ) {
		var nodes = attrs[i].nodes;
		bezierLine.moveToPoint( NSMakePoint( nodes[0].ancherPointX, nodes[0].ancherPointY ) );

		for ( var j = 1; j < nodes.length; j++ ) {
			var ancher        = NSMakePoint( nodes[j].ancherPointX, nodes[j].ancherPointY );
			var currentHandle = NSMakePoint( nodes[j].predPointX,   nodes[j].predPointY );
			var prevHandle    = NSMakePoint( nodes[j - 1].succPointX, nodes[j - 1].succPointY );
			// log( 'ancher:        ' + ancher );
			// log( 'currentHandle: ' + currentHandle );
			// log( 'prevHandle:    ' + prevHandle );
			[bezierLine curveToPoint:ancher controlPoint1:prevHandle controlPoint2:currentHandle];
		};
		if ( attrs[i].isClosed ) {
			[bezierLine 
				curveToPoint:NSMakePoint( nodes[0].ancherPointX, nodes[0].ancherPointY ) 
				controlPoint1:NSMakePoint( nodes[nodes.length - 1].succPointX, nodes[nodes.length - 1].succPointY )
				controlPoint2:NSMakePoint( nodes[0].predPointX, nodes[0].predPointY )
			];
			bezierLine.closePath();
			// log( 'closed-ancher:        ' + NSMakePoint( nodes[0].ancherPointX, nodes[0].ancherPointY ) );
			// log( 'closed-currentHandle: ' + NSMakePoint( nodes[nodes.length - 1].succPointX, nodes[nodes.length - 1].succPointY ) );
			// log( 'closed-prevHandle:    ' + NSMakePoint( nodes[0].predPointX, nodes[0].predPointY ) );
		}
	}

	var shape = MSShapeGroup.shapeWithBezierPath( bezierLine );

	return shape;
}

function setGrid( artboard, gridAttrs ) {
	var grid = MSSimpleGrid.new();
	grid.setGridSize( gridAttrs.gridSize.x );
	artboard.grid = grid;
}

function addGuideline ( artboard, guides, grid ) {
	var vRuler = artboard.verticalRulerData();
	var hRuler = artboard.horizontalRulerData();

	// set origin
	vRuler.setBase( grid.x );
	hRuler.setBase( grid.y );

	// set guidelines
	for ( var i in guides.x ) {
		vRuler.addGuideWithValue( guides.x[i] );
	}
	for ( var i in guides.y ) {
		hRuler.addGuideWithValue( guides.y[i] );
	}
}

function getHexColor( color ) {
	if( 7 == color.length ) return color;
	return color.slice( 0, 7 );
}

function getOpacity( color ) {
	if( 7 == color.length ) return 1;

	var digit = Math.pow( 10, 2 );
	var hex = color.slice( 7, 9 );
	var opacity = parseInt( '0x' + hex ).toString( 10 ) / 255;
	opacity = Math.floor( opacity * digit );
	opacity = opacity / digit;

	return opacity;
}

function setFlatFill() {
	var doc = context.document;

	var rectangle = doc.currentPage().addLayerOfType( 'rectangle' );
	rectangle.setName( 'test rectangle' );
	rectangle.frame().x = 0;
	rectangle.frame().y = 0;
	rectangle.frame().width = 100;
	rectangle.frame().height = 100;

	var shepeFill = rectangle.style().fills().addNewStylePart();
	shepeFill.color = MSColor.colorWithSVGString( 'ff0000' );

}

function addPatternFill( shape, attrs ) {
	var filePath = NSImage.new().initWithContentsOfFile( attrs.replace( "file:///Macintosh%20HD/", "/" ) );
	var shapeStyle = shape.style();
	var shapeFill = shapeStyle.fill();
	
	var fillCollection = shapeFill.documentData().images();
	shapeFill.setFillType(4);
	shapeFill.setPatternImage_collection_( filePath, fillCollection );
}

function addGradientFill( shape, attrs ) {
	var shapeStyle = shape.style();
	// shapeStyle.fills().addNewStylePart();
	var shapeFill = shapeStyle.fill();
	shapeFill.setFillType( 1 ); // gradient fill

	var gradient = shapeFill.gradient();
	switch ( attrs.gradientType ) {
		case 'linear':
			gradient.setGradientType( 0 );
			break;
		case 'radial':
			gradient.setGradientType( 1 );
			break;
		case 'conical':
			gradient.setGradientType( 2 );
			break;
		default:
			gradient.setGradientType( 0 );
			break;
	}

	var gradientNodes = attrs.gradientNodes.nodes.concat( attrs.gradientNodes.opacityNodes );

	// sort gradient stops by position
	for ( var i = 0; i < gradientNodes.length - 1; i++ ) {
		for ( var j = gradientNodes.length - 1; j > i; j-- ) {
			if ( gradientNodes[j - 1].position > gradientNodes[j].position ) {
				var exchenge = gradientNodes[j - 1];
				gradientNodes[j - 1] = gradientNodes[j];
				gradientNodes[j] = exchenge;
			}
		};
	};
	log( 'gradientNodes' );
	log( gradientNodes );

	// get gradient attributes
	var optimazedPoints = [];
	for ( var i = 0, index = 0; i < gradientNodes.length; i++ ) {
		for ( var j = i; j < gradientNodes.length; j++ ) {
			if ( !gradientNodes[i].isOpacityNode ) {
				if ( gradientNodes[j].isOpacityNode && gradientNodes[i].position <= gradientNodes[j].position ) {
					optimazedPoints[index] = {};
					optimazedPoints[index].color = gradientNodes[i].color;
					optimazedPoints[index].position = gradientNodes[i].position;
					if ( 9 == gradientNodes[j].color.length ) {
						var assets = {prev:{}, next:{}, current:{}};
						assets.prev.position    = optimazedPoints[index - 1].position;
						assets.prev.opacity     = optimazedPoints[index - 1].opacity;
						assets.next.position    = gradientNodes[j].position;
						assets.next.opacity     = getOpacityByDigit( gradientNodes[j].color.slice( 7, 9 ) );
						assets.current.position = optimazedPoints[index].position;
						optimazedPoints[index].opacity = getGradientOpacity( assets );
					} else {
						optimazedPoints[index].opacity = 1;
					}
					index++;
					break;
				}
			} else if ( gradientNodes[i - 1].position != gradientNodes[i].position ) {
				var gradientAssets = {prev:{}, next:{}, current:{}};

				gradientAssets.prev.color    = optimazedPoints[index - 1].color;
				gradientAssets.prev.position = optimazedPoints[index - 1].position;
				gradientAssets.next.color    = optimazedPoints[index - 1].color;
				gradientAssets.next.position = 1;

				for ( var k = j; k < gradientNodes.length; k++ ) {
					if ( !gradientNodes[k].isOpacityNode ) {
						gradientAssets.next.color    = gradientNodes[k].color;
						gradientAssets.next.position = gradientNodes[k].position;
					} 
				}

				gradientAssets.current.position = gradientNodes[i].position;

				optimazedPoints[index] = {};
				optimazedPoints[index].color = getGradientStopColorOnOpacitySide( gradientAssets );
				optimazedPoints[index].position = gradientNodes[i].position;
				if ( 9 == gradientNodes[i].color.length ) {
					optimazedPoints[index].opacity = getOpacityByDigit( gradientNodes[i].color.slice( 7, 9 ) );
				} else {
					optimazedPoints[index].opacity = 1;
				}
				index++;
				break;
			}
		}
	}
	log( optimazedPoints );

	var orignPoint = optimazedPoints.length;
	for ( var i = 0; i < orignPoint; i++ ) {
		if ( 0 != optimazedPoints[i].position && 1 != optimazedPoints[i].position ) {
			gradient.addStopAtLength( floorWithDigit( optimazedPoints[i].position, 2 ) );
		}
	}
	for ( var i = 0; i < orignPoint; i++ ) {
		var gradientColor = MSColor.colorWithSVGString( optimazedPoints[i].color );
		gradientColor.alpha = optimazedPoints[i].opacity;
		gradient.setColor_atIndex_( gradientColor, i );
	}

	var shapeX = shape.frame().x();
	var shapeY = shape.frame().y();
	var shapeW = shape.frame().width();
	var shapeH = shape.frame().height();
	var startX = ( attrs.gradientPoint[0].x - shapeX ) / shapeW;
	var startY = ( attrs.gradientPoint[0].y - shapeY ) / shapeH;
	gradient.setPoint_atIndex_( CGPointMake( startX, startY ), 0 );
	if ( 'conical' != attrs.gradientType ) {
		var endX   = ( attrs.gradientPoint[1].x - shapeX ) / shapeW;
		var endY   = ( attrs.gradientPoint[1].y - shapeY ) / shapeH;
		gradient.setPoint_atIndex_( CGPointMake( endX, endY ), orignPoint - 1 );
	}
}

// utilities
function getCoordfromTrigFunc( radius, angle ) {
	var coord = {}
	angle = 360 - angle;

	coord.x = radius * Math.cos( angle / 180 * Math.PI );
	coord.y = radius * Math.sin( angle / 180 * Math.PI );

	return coord;
}

function getGradientStopColorOnOpacitySide ( assets ) {
	log( assets );

	var pr = hex2Digit( assets.prev.color.slice( 1, 3 ) ) - 0;
	var pg = hex2Digit( assets.prev.color.slice( 3, 5 ) ) - 0;
	var pb = hex2Digit( assets.prev.color.slice( 5, 7 ) ) - 0;

	var nr = hex2Digit( assets.next.color.slice( 1, 3 ) ) - 0;
	var ng = hex2Digit( assets.next.color.slice( 3, 5 ) ) - 0;
	var nb = hex2Digit( assets.next.color.slice( 5, 7 ) ) - 0;

	log( 'prevColor: ' + pr + ' / ' + pg + ' / ' + pb + ' | nextColor: ' + nr + ' / ' + ng + ' / ' + nb );

	var range = assets.next.position - assets.prev.position;
	var offset = 1 / range;
	log( 'offset:' + offset );
	var localRangePosition = ( assets.current.position - assets.prev.position ) * offset;
	log( 'range: ' + range + ' / offset: ' + offset + ' / localRangePosition: ' + localRangePosition );
	
	var r = floorWithDigit( pr + ( nr - pr ) * localRangePosition, 0 );
	var g = floorWithDigit( pg + ( ng - pg ) * localRangePosition, 0 );
	var b = floorWithDigit( pb + ( nb - pb ) * localRangePosition, 0 );

	r = digit2Hex( r );
	g = digit2Hex( g );
	b = digit2Hex( b );
	log( 'retrun: ' + '#' + r + g + b );

	return '#' + r + g + b;
}

function getGradientOpacity ( assets ) {

	var range = assets.next.position - assets.prev.position;
	var offset = 1 / range;
	var localRangePosition = ( assets.current.position - assets.prev.position ) * offset;

	var opacity = floorWithDigit( assets.prev.opacity + ( assets.next.opacity - assets.prev.opacity ) * localRangePosition, 2 );

	return opacity;
}

function floorWithDigit ( _val, _specifiedDigit ) {
	var digit = Math.pow( 10, _specifiedDigit );
	var val = Math.floor( _val * digit );

	return  val / digit;
}

function getOpacityByDigit ( _hex ) {
	var digit = ( parseInt( '0x' + _hex ).toString( 10 ) ) / 255;

	return floorWithDigit( digit, 2 );
}

function digit2Hex ( _digit ) {
	var hex = parseInt( _digit ).toString( 16 );
	if ( 1 == hex.length ) hex = '0' + hex;
	return hex;
}

function hex2Digit ( _hex ) {
	return ( parseInt( '0x' + _hex ).toString( 10 ) );
}
