@import 'lib/const.js';

var onRun = function ( context ) {
	log( 'Start Proccessing ------------------------------------------' );
	var doc = context.document;
	var currentPage = doc.currentPage();

	// var userJSON = [doc askForUserInput:"Paste your JSON here:" initialValue:""];
	// if ( !userJSON ) return false;
	// var json = userJSON;
	// // var fwJSON = JSON.parse( json );
	// var fwJSON = ( new Function( 'return ' + json ) )();

	var openPanel = NSOpenPanel.openPanel();
	    openPanel.setTitle( "Choose a JSON File" );
	    openPanel.setCanCreateDirectories = false;
	    openPanel.setCanChooseFiles = true;

	var fileTypes = ['json'];
	var openPanelButtonPressed = openPanel.runModalForDirectory_file_types_( nil, nil, fileTypes );

	if ( openPanelButtonPressed == NSFileHandlingPanelOKButton ) {
		var filePath = openPanel.URL().path();
		var fwJSON = JSON.parse( NSString.stringWithContentsOfFile( filePath ) ); 
		log( 'Open File from: ' + filePath );
	} else {
		return false;
	}

	var artboardPageOffset = 0; 
	var artboardStateOffset = 0; 
	for ( var i = 0; i < fwJSON.pages.length; i++ ) {
		log( 'Page: ' + fwJSON.pages[i].pageName + ' //////////////////////////////////////////' );
		for ( var stateIndex = 0; stateIndex < fwJSON.pages[i].frames.length; stateIndex++ ) {
			log( 'Frame (state): ' + stateIndex + ' ------------------------------------------>' );
			var artboard = MSArtboardGroup.new();
			artboard.setName( fwJSON.pages[i].pageName );
			artboard.frame().setX( artboardPageOffset );
			artboard.frame().setY( artboardStateOffset );
			artboard.frame().setWidth( fwJSON.pages[i].width );
			artboard.frame().setHeight( fwJSON.pages[i].height );
			artboardStateOffset = artboardStateOffset + fwJSON.pages[i].height + 100;
			// currentPage.addLayer( artboard );
			currentPage.addLayers( NSArray.arrayWithObjects( artboard ) );
			var artboards = doc.currentPage().artboards();

			setGrid( artboard, fwJSON.documentSetting.grid );
			addGuideline( artboard, fwJSON.pages[i].guides, fwJSON.documentSetting.grid.gridOrigin );
			fwJSON.pages[i].frames[stateIndex].topLayers.reverse();
			createElements( artboard, fwJSON.pages[i].frames[stateIndex].topLayers );
			// log( fwJSON.pages[i].width );
		};
		artboardPageOffset += fwJSON.pages[i].width + 100;
		artboardStateOffset = 0;
	}

	log( '------------------------------------------ Close Proccessing' );

}

function createElements( parent, elems, isMask ) {
	log( '-> Child Layer Proccessing' );
	if ( !isMask ) isMask = false;
	// var shape;
	for ( var i = elems.length - 1; i >= 0; i-- ) {
		log( '  -> Proccessing: ' + elems[i].name + ' / ' + elems[i].type );
		var elemsType = elems[i].type;
		if ( 'layer' == elemsType && elems[i].hasChildren ) {
			log( '     Type: Layer' );
			shape = createGroup( parent, elems[i], true );
			createElements( shape, elems[i].elems );
			if ( 5 < fw2json.appVer.minor ) {
				shape.resizeRoot( false );
			} else {
				shape.resizeToFitChildrenWithOption( false );
			}
		}
		if ( 'text' == elemsType ) {
			log( '     Type: Text: ' + elems[i].textChars );
			var shape = createText( parent, elems[i], isMask );
			shape.setName( elems[i].textChars );
		}
		if ( 'bitmap' == elemsType ) {
			log( '     Type: Bitmap' );
			var tempParent = ( null != elems[i].mask ) ? createMask( parent, elems[i] ) : parent;
			var shape = importBitmap( tempParent, elems[i], isMask );
			addContextSettings( shape, elems[i] );
		}
		if ( 'rectangle' == elemsType ) {
			log( '     Type: Rectangle' );
			var tempParent = ( null != elems[i].mask ) ? createMask( parent, elems[i] ) : parent;
			var shape = createRectangle( tempParent, elems[i], isMask );
			shape.setName( elems[i].name );
			addContextSettings( shape, elems[i] );
			if ( !isMask ) {
				addPathAttributes( shape, elems[i].pathAttributes );
			}
		}
		if ( 'path' == elemsType ) {
			log( '     Type: Bezier Path' );
			var tempParent = ( null != elems[i].mask ) ? createMask( parent, elems[i] ) : parent;
			var shape = addBezier( tempParent, elems[i].bezierPath, isMask );
			shape.setName( elems[i].name );
			addContextSettings( shape, elems[i] );
			tempParent.addLayers( [shape] );
			if ( !isMask ) {
				addPathAttributes( shape, elems[i].pathAttributes );
			}
		}
		if ( 'slice' == elemsType ) {
			log( '     Type: Slice' );
			var shape = createSlice( parent, elems[i], isMask );
		}
		if ( 'group' == elemsType ) {
			log( '     Type: Layer Group' );
			var tempParent = ( null != elems[i].mask ) ? createMask( parent, elems[i] ) : parent;
			var shape = createGroup( tempParent, elems[i], isMask );
			addContextSettings( shape, elems[i] );
			createElements( shape, elems[i].elements );
			if ( 5 < fw2json.appVer.minor ) {
				shape.resizeRoot( false );
			} else {
				shape.resizeToFitChildrenWithOption( false );
			}
		}
		if ( 'symbol' == elemsType ) {
			log( '     Type: Layer Group' );
			var shape = createGroup( parent, elems[i] );
			addContextSettings( shape, elems[i] );
			createElements( shape, elems[i].elements );
			if ( 5 < fw2json.appVer.minor ) {
				shape.resizeRoot( false );
			} else {
				shape.resizeToFitChildrenWithOption( false );
			}
		}
		if ( null != elems[i].effectList ) {
			addEffects( shape, elems[i].effectList.effects );
		}
		if ( null != elems[i].mask ) {
			// parent.resizeRoot( true );
		}
		shape.isLocked = elems[i].locked;
		shape.isVisible = elems[i].visible;
	};
	// parent.resizeRoot( true );
	if ( !isMask ) {
		log( '!!! Finished createElements !!!');
		log( '!!! resizeRoot() to ' + parent.name() );
		if ( 5 < fw2json.appVer.minor ) {
			parent.resizeRoot( false );
		} else {
			parent.resizeToFitChildrenWithOption( false );
		}
	}

	return shape;
}

function addContextSettings( shape, attrs ) {
	var contextSettings = shape.style().contextSettings();
	contextSettings.opacity = Math.round( attrs.opacity ) / 100;
	if ( fw2json.blendMode[attrs.blendMode] ) {
		contextSettings.blendMode = fw2json.blendMode[attrs.blendMode];
	}
}

function setFrame( targetLayer, attrs, parent ) {
	log( '     -> setFrame()' );
	// log( parent );
	// log( parent.absoluteRect() );
	// log( parent.frame() );
	var offsetX = parent ? parent.absoluteRect().x() : 0;
	var offsetY = parent ? parent.absoluteRect().y() : 0;
	targetLayer.frame().x = attrs.left - offsetX;// - parent.absoluteRect().x();
	targetLayer.frame().y = attrs.top  - offsetY;// - parent.absoluteRect().y();
	targetLayer.frame().width = attrs.width;
	targetLayer.frame().height = attrs.height;

	return targetLayer;
}

function addPathAttributes( shape, attrs ) {
	if ( null != attrs.fill ) {
		var fill = shape.style().fills().addNewStylePart();

		if ( 'gradient' == attrs.fillType ) {
			addGradientFill( shape, attrs );
		} else if ( 'pattern' == attrs.fillType ) {
			addPatternFill( shape, attrs.fill.pattern.patternURI );
		} else {
			var color = MSColor.colorWithSVGString( getHexColor( attrs.fillColor ) );
			color.alpha = getOpacity( attrs.fillColor );
			fill.color = color;
		}
	}

	if ( null != attrs.brush ) {
		addBorder( shape, attrs );
	}
}

function addBorder( shape, attrs ) {
	var border = shape.style().borders().addNewStylePart();
	var color = MSColor.colorWithSVGString( getHexColor( attrs.brushColor ) );
	color.alpha = getOpacity( attrs.brushColor );
	border.color = color;
	border.thickness = attrs.brush.diameter;
	switch ( attrs.brushPlacement ) {
		case 'center':
			border.setPosition( 0 );
			break; 
		case 'inside':
			border.setPosition( 1 );
			break; 
		case 'outside':
			border.setPosition( 2 );
			break; 
		default:
			border.setPosition( 0 );
			break; 
	}

	var borderOptions = shape.style();
	switch ( attrs.brush.shape ) {
		case 'square':
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
		case 'circle':
			borderOptions.borderOptions().setLineCapStyle( 1 );
			borderOptions.borderOptions().setLineJoinStyle( 1 );
			break; 
		default:
			borderOptions.borderOptions().setLineCapStyle( 0 );
			borderOptions.borderOptions().setLineJoinStyle( 0 );
			break; 
	}

	if ( 1 == attrs.brush.numDashes || 2 == attrs.brush.numDashes ) {
		var dashAttrs = [];
		var gapOffest = attrs.brush.shape == 'circle' ? attrs.brush.diameter : 0;
		for ( var i = 0; i < attrs.brush.numDashes; i++ ) {
			dashAttrs[i * 2] = attrs.brush['dashOnSize' + ( i + 1 )];
			dashAttrs[i * 2 + 1] = attrs.brush['dashOffSize' + ( i + 1 )] + gapOffest;
		}
		borderOptions.borderOptions().setDashPattern( dashAttrs );
	}
}

function addEffects( shape, attrs ) {
	for ( var i = attrs.length - 1; i >= 0; i-- ) {
		log( '  Applied Effect: ' + attrs[i].name );
		if ( 'ドロップシャドウ' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().shadows().addNewStylePart();
			effect.blurRadius = attrs[i].ShadowBlur;
			
			var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
			effect.offsetX = coord.x;
			effect.offsetY = coord.y;
			effect.spread = 0;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
			color.alpha = getOpacity( attrs[i].ShadowColor );
			effect.color = color;
		}
		if ( 'シャドウ (内側)' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().innerShadows().addNewStylePart();
			effect.blurRadius = attrs[i].ShadowBlur;
			
			var coord = getCoordfromTrigFunc( attrs[i].ShadowDistance, attrs[i].ShadowAngle );
			effect.offsetX = coord.x;
			effect.offsetY = coord.y;
			effect.spread = 0;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].ShadowColor ) );
			color.alpha = getOpacity( attrs[i].ShadowColor );
			effect.color = color;
		}
		if ( 'グロー' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().shadows().addNewStylePart();
			effect.blurRadius = attrs[i].MaskSoftness;

			effect.offsetX = 0;
			effect.offsetY = 0;
			effect.spread = attrs[i].GlowWidth;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
			color.alpha = attrs[i].BevelContrast / 100;
			effect.color = color;
		}
		if ( '光彩 (内側)' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().innerShadows().addNewStylePart();
			effect.blurRadius = attrs[i].MaskSoftness;
			
			effect.offsetX = 0;
			effect.offsetY = 0;
			effect.spread = attrs[i].GlowWidth;

			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].OuterBevelColor ) );
			color.alpha = attrs[i].BevelContrast / 100;
			effect.color = color;
		}
		if ( 'ソリッドシャドウ…' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].color ) );
			color.alpha = 1;

			for ( var j = attrs[i].distance - 1; j >= 0; j-- ) {
				var effect = shape.style().shadows().addNewStylePart();
				effect.blurRadius = 0;
				
				var coord = getCoordfromTrigFunc( j, attrs[i].angle );
				effect.offsetX = coord.x;
				effect.offsetY = coord.y;
				effect.spread = 0;

				effect.color = color;
			};
		}
		if ( 'ぼかし (ガウス)...' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().blur();
			effect.isEnabled = 1;
			effect.type = 0;
			effect.radius = attrs[i].gaussian_blur_radius;
		}
		if ( 'ぼかし (移動)...' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().blur();
			effect.isEnabled = 1;
			effect.type = 1;
			effect.radius = attrs[i].motion_blur_distance;
			effect.motionAngle = attrs[i].motion_blur_angle;
		}
		if ( 'ぼかし (ズーム)...' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().blur();
			effect.isEnabled = 1;
			effect.type = 2;
			effect.radius = attrs[i].zoom_blur_amount;
		}
		if ( 'ノイズを追加...' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().fills().addNewStylePart();
			effect.fillType = 5;
			if ( attrs[i].add_noise_use_color ) {
				effect.noiseIndex = 3;
			} else {
				effect.noiseIndex = 2;
			}
			effect.contextSettings().blendMode = 9;
			effect.contextSettings().opacity = Math.round( attrs[i].add_noise_amount / 4 ) / 100;
		}
		if ( 'カラーの塗り' == attrs[i].name && attrs[i].EffectIsVisible ) {
			var effect = shape.style().fills().addNewStylePart();
			effect.setFillType(0);
			var color = MSColor.colorWithSVGString( getHexColor( attrs[i].Color ) );
			color.alpha = attrs[i].Opacity / 100;
			effect.contextSettings().blendMode = fw2json.solidFill[attrs[i].Blendmode - 1];
			effect.color = color;
		}
		if ( 'Photoshop' == attrs[i].name.substr( 0, 9 ) ) {
			// log( '  PsLE:' );
			for ( var j = fw2json.PsLE.length - 1; j >= 0; j-- ) {
				// log( '    Flag: ' + fw2json.PsLE[j] + ': ' + attrs[i][fw2json.PsLE[j]].substring( 0, 1 ) );
				if( '1' == attrs[i][fw2json.PsLE[j]].substring( 0, 1 ) ) {
					// log( '      isEnabled:' );
					var psleAttrs = attrs[i][fw2json.PsLE[j]].split( '&' );
					// log( '      psleAttrs:' );
					// log( psleAttrs );
					switch ( fw2json.PsLE[j] ) {
						case 'satin':
							break;
						case 'dropShadow':
							var effect = shape.style().shadows().addNewStylePart();
							effect.blurRadius = psleAttrs[6];
							
							var coord = getCoordfromTrigFunc( psleAttrs[5], psleAttrs[3], true );
							effect.offsetX = coord.x;
							effect.offsetY = coord.y;
							effect.spread = psleAttrs[7];

							var originColor = psleAttrs[11].split( ';' );
							var color = MSColor.colorWithRGBADictionary( {
								r: bit2Percent( originColor[1] ), 
								g: bit2Percent( originColor[2] ), 
								b: bit2Percent( originColor[3] )
							} );
							color.alpha = psleAttrs[1] / 100;
							effect.color = color;
							break;
						case 'innerShadow':
							var effect = shape.style().innerShadows().addNewStylePart();
							effect.blurRadius = psleAttrs[6];
							
							var coord = getCoordfromTrigFunc( psleAttrs[5], psleAttrs[3], true );
							effect.offsetX = coord.x;
							effect.offsetY = coord.y;
							effect.spread = psleAttrs[7];

							var originColor = psleAttrs[11].split( ';' );
							var color = MSColor.colorWithRGBADictionary( {
								r: bit2Percent( originColor[1] ), 
								g: bit2Percent( originColor[2] ), 
								b: bit2Percent( originColor[3] )
							} );
							color.alpha = psleAttrs[1] / 100;
							effect.color = color;
							break;
						case 'outerGlow':
							var effect = shape.style().shadows().addNewStylePart();
							var subAttrs = psleAttrs[3].split( ':' );
							effect.blurRadius = subAttrs[2];
							
							effect.offsetX = 0;
							effect.offsetY = 0;
							effect.spread = subAttrs[1];

							var originColor = psleAttrs[5].split( ';' );
							var color = MSColor.colorWithRGBADictionary( {
								r: bit2Percent( originColor[1] ), 
								g: bit2Percent( originColor[2] ), 
								b: bit2Percent( originColor[3] )
							} );
							color.alpha = subAttrs[0] / 100;
							effect.color = color;

							var blendMode = psleAttrs[2];
							effect.contextSettings().blendMode = fw2json.blendMode[blendMode];
							break;
						case 'innerGlow':
							var effect = shape.style().innerShadows().addNewStylePart();
							var subAttrs = psleAttrs[3].split( ':' );
							effect.blurRadius = subAttrs[2];
							
							effect.offsetX = 0;
							effect.offsetY = 0;
							effect.spread = subAttrs[1];

							var originColor = psleAttrs[5].split( ';' );
							var color = MSColor.colorWithRGBADictionary( {
								r: bit2Percent( originColor[1] ), 
								g: bit2Percent( originColor[2] ), 
								b: bit2Percent( originColor[3] )
							} );
							color.alpha = subAttrs[0] / 100;
							effect.color = color;
							
							var blendMode = psleAttrs[2];
							effect.contextSettings().blendMode = fw2json.blendMode[blendMode];
							break;
						case 'solidFill':
							var effect = shape.style().fills().addNewStylePart();
							effect.setFillType(0);
							var originColor = psleAttrs[3].split( ';' );
							var color = MSColor.colorWithRGBADictionary( {
								r: bit2Percent( originColor[1] ), 
								g: bit2Percent( originColor[2] ), 
								b: bit2Percent( originColor[3] )
							} );
							color.alpha = psleAttrs[1] / 100;
							var blendMode = psleAttrs[2];
							effect.contextSettings().blendMode = fw2json.blendMode[blendMode];
							effect.color = color;
							break;
						case 'gradientFill':
							var effect = shape.style().fills().addNewStylePart();
							effect.setFillType(1);
							// log( '      opacity: ' + ( psleAttrs[3] ) );
							// log( '      opacity: ' + ( psleAttrs[3] / 100 ) );
							effect.contextSettings().opacity = psleAttrs[3] / 100;
							var coord = getCoordfromTrigFunc( 1, psleAttrs[4], true );
							var coordStretch = ( Math.abs( coord.x ) > Math.abs( coord.y ) ) ? 1 / Math.abs( coord.x ) : 1 / Math.abs( coord.y );
							coord.x = coord.x * coordStretch;
							coord.y = coord.y * coordStretch;
							var startX = 0;
							var startY = 0;
							// offset coordinate
							if ( 0 > coord.x ) {
								startX = startX + Math.abs( coord.x );
								coord.x = 0;
							}
							if ( 0 > coord.y ) {
								startY = startY + Math.abs( coord.y );
								coord.y = 0;
							}
							effect.gradient().setPoint_atIndex_( CGPointMake( startX, startY ), 0 )
							effect.gradient().setPoint_atIndex_( CGPointMake( coord.x, coord.y ), 1 )
							break;
						case 'patternFill':
							break;
						case 'bevelEmboss':
							break;
						case 'stroke':
							var effect = shape.style().borders().addNewStylePart();
							var originColor = psleAttrs[4].split( ';' );
							var color = MSColor.colorWithRGBADictionary( {
								r: bit2Percent( originColor[1] ), 
								g: bit2Percent( originColor[2] ), 
								b: bit2Percent( originColor[3] )
							} );
							color.alpha = psleAttrs[1] / 100;
							effect.color = color;
							effect.thickness = psleAttrs[2];
							var blendMode = psleAttrs[3];
							effect.contextSettings().blendMode = fw2json.blendMode[blendMode];
							switch ( psleAttrs[5] ) {
								case 'centeredFrame':
									effect.setPosition( 0 );
									break; 
								case 'insetFrame':
									effect.setPosition( 1 );
									break; 
								case 'outsetFrame':
									effect.setPosition( 2 );
									break; 
								default:
									effect.setPosition( 0 );
									break; 
							}
							break;
					}
				}
			};
		}
	};
}

function importBitmap( parent, attrs, isMask ) {
	var filePath = attrs.uri;
	filePath = filePath.replace( "file:///Macintosh%20HD/", "/" );

	var bitmap = MSBitmapLayer.bitmapLayerWithImageFromPath( filePath.toString() );
	bitmap = setFrame( bitmap, attrs, ( isMask ? parent : false ) );
	bitmap.name = attrs.name;

	parent.addLayers( [bitmap] );

	return bitmap;
}

function createMask( parent, attrs ) {
	log( '    -> createMask' );
	// log( attrs );
	var maskGroup = parent.addLayerOfType( 'group' );
	maskGroup.setName( attrs.name );
	var mask = createElements( maskGroup, attrs.mask.element, true );
	log( '     Mask Object: ' + mask.frame() );
	mask.setHasClippingMask( true );
	if ( 'mask to path' == attrs.mask.mode) {
		mask.clippingMaskMode = 0; // Outline
	} else {
		mask.clippingMaskMode = 1; // Alpha
	}
	// log( '!!! resizeRoot()');
	// parent.resizeRoot( false );

	return maskGroup;
}

function createGroup( parent, attrs, _isLayer ) {
	var isLayer = _isLayer || false;
	var group = parent.addLayerOfType( 'group' );
	group.setName( attrs.name || attrs.name );
	group.hasClickThrough = ( isLayer ) ? 1 : 0;

	return group;
}

function createText( parent, attrs, isMask ) {
	var text = parent.addLayerOfType( 'text' );
	text = setFrame( text, attrs, ( isMask ? parent : false ) );
	if ( !attrs.autoExpand ) {
		text.textBehaviour = 1;
	}

	var textPart = [0];
	var textPartNum = attrs.textRuns.length;
	text.stringValue = '';
	for ( var i = 0; i < textPartNum; i++ ) {
		text.stringValue = text.stringValue() + attrs.textRuns[i].characters;
		textPart.push( textPart[i] + attrs.textRuns[i].characters.length );
	}

	if ( 1 < textPartNum ) {
		for ( var i = 0; i < textPartNum; i++ ) {
			var range = NSMakeRange( textPart[i], textPart[i + 1] - textPart[i] );
			var textFont = NSFont.fontWithName_size_( attrs.textRuns[i].face, attrs.textRuns[i].size );
			var color = hexToColor( attrs.textRuns[i].fillColor );

			text.setIsEditingText( true );
			text.addAttribute_value_forRange( NSFontAttributeName, textFont, range );
			text.addAttribute_value_forRange( NSForegroundColorAttributeName, color, range );
			text.setIsEditingText( false );
		}
	} else {
		text.fontSize           = attrs.fontSize;
		text.lineSpacing        = attrs.leading;
		text.fontPostscriptName = attrs.fontFace;
		text.textColor          = MSColor.colorWithSVGString( attrs.fillColor );
	}
	
	switch ( attrs.alignment ) {
		case 'left':
			text.setTextAlignment( 0 );
			break;
		case 'right':
			text.setTextAlignment( 1 );
			break;
		case 'center':
			text.setTextAlignment( 2 );
			break;
		default:
			text.setTextAlignment( 0 );
			break;
	}
	
	return text;
}

function createRectangle( parent, attrs, isMask ) {
	var originMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	var isTransform = false;
	for (var i = 0; i < originMatrix.length; i++) {
		if ( originMatrix[i] != attrs.transform.matrix[i] && ( 6 != i && 7 != i) ) {
			isTransform = true;
			break;
		}
	}
	if ( isTransform ) {
		var m = attrs.transform.matrix;
		var ow = attrs.originalSides['right'] - attrs.originalSides['left'],
		    oh = attrs.originalSides['bottom'] - attrs.originalSides['top'];
		var ol = attrs.originalSides['left'],
		    ot = attrs.originalSides['top'],
		    ob = attrs.originalSides['bottom'],
		    or = attrs.originalSides['right'];
		var rectangle = NSBezierPath.bezierPath();
		rectangle.moveToPoint(NSMakePoint( m[0] * ol + m[3] * ot + m[6], m[1] * ol + m[4] * ot + m[7] ));
		rectangle.lineToPoint(NSMakePoint( m[0] * or + m[3] * ot + m[6], m[1] * or + m[4] * ot + m[7] ));
		rectangle.lineToPoint(NSMakePoint( m[0] * or + m[3] * ob + m[6], m[1] * or + m[4] * ob + m[7] ));
		rectangle.lineToPoint(NSMakePoint( m[0] * ol + m[3] * ob + m[6], m[1] * ol + m[4] * ob + m[7] ));
		rectangle.closePath();
		log( rectangle.treeAsDictionary() );

		var shape = MSShapeGroup.shapeWithBezierPath( rectangle );
		for (var i = 0; i < shape.layers().firstObject().path().points().length(); i++) {
			shape.layers().firstObject().path().points().objectAtIndex( i ).setCornerRadius( attrs.radius );
		}
	} else {
		var rectangle = MSRectangleShape.new();

		rectangle = setFrame( rectangle, attrs, ( isMask ? parent : false ) );

		var shape = MSShapeGroup.shapeWithPath( rectangle );
		shape.layers().firstObject().cornerRadiusFloat = attrs.radius;
		// shape.layers().firstObject().cornerRadiusString = "7/0/0/10";
	}
	parent.addLayers( [shape] );

	return shape;
}

function createSlice( parent, attrs, isMask ) {
	var slice = MSSliceLayer.new();
	slice = setFrame( slice, attrs, ( isMask ? parent : false ) );
	slice.setName( attrs.baseName );

	parent.addSlice( slice );

	return slice;
}

function addBezier( parent, attrs, isMask ) {
	var bezierLine = NSBezierPath.bezierPath();
	log( '     -> addBezier Parent Frame' );
	// log( parent.frame() );

	// var offsetX = parent ? parent.absoluteRect().x() : 0;
	// var offsetY = parent ? parent.absoluteRect().y() : 0;
	var offsetX = 0;
	var offsetY = 0;
	log ( '        -> Offset: ' + offsetX + ' / ' + offsetY );

	for ( var i = 0; i < attrs.length; i ++ ) {
		var nodes = attrs[i].nodes;
		bezierLine.moveToPoint( NSMakePoint( nodes[0].x - offsetX, nodes[0].y - offsetY ) );

		for ( var j = 1; j < nodes.length; j++ ) {
			var ancher        = NSMakePoint( nodes[j].x - offsetX, nodes[j].y - offsetY );
			var currentHandle = NSMakePoint( nodes[j].predX - offsetX,   nodes[j].predY - offsetY );
			var prevHandle    = NSMakePoint( nodes[j - 1].succX - offsetX, nodes[j - 1].succY - offsetY );
			// log( 'ancher:        ' + ancher );
			// log( 'currentHandle: ' + currentHandle );
			// log( 'prevHandle:    ' + prevHandle );
			[bezierLine curveToPoint:ancher controlPoint1:prevHandle controlPoint2:currentHandle];
		};
		if ( attrs[i].isClosed ) {
			[bezierLine 
				curveToPoint:NSMakePoint( nodes[0].x - offsetX, nodes[0].y - offsetY ) 
				controlPoint1:NSMakePoint( nodes[nodes.length - 1].succX - offsetX, nodes[nodes.length - 1].succY - offsetY )
				controlPoint2:NSMakePoint( nodes[0].predX - offsetX, nodes[0].predY - offsetY )
			];
			bezierLine.closePath();
			// log( 'closed-ancher:        ' + NSMakePoint( nodes[0].x, nodes[0].y ) );
			// log( 'closed-currentHandle: ' + NSMakePoint( nodes[nodes.length - 1].succX, nodes[nodes.length - 1].succY ) );
			// log( 'closed-prevHandle:    ' + NSMakePoint( nodes[0].predX, nodes[0].predY ) );
		}
	}
	var shape = MSShapeGroup.shapeWithBezierPath( bezierLine );

	return shape;
}

function setGrid( parent, gridAttrs ) {
	var grid = MSSimpleGrid.new();
	grid.setGridSize( gridAttrs.gridSize.x );
	parent.grid = grid;
}

function addGuideline ( parent, guides, grid ) {
	var vRuler = parent.verticalRulerData();
	var hRuler = parent.horizontalRulerData();

	// set origin
	vRuler.setBase( grid.x );
	hRuler.setBase( grid.y );

	// set guidelines
	for ( var i in guides.x ) {
		vRuler.addGuideWithValue( guides.x[i] );
	}
	for ( var i in guides.y ) {
		hRuler.addGuideWithValue( guides.y[i] );
	}
}

function addPatternFill( shape, attrs ) {
	var filePath = NSImage.new().initWithContentsOfFile( attrs.replace( "file:///Macintosh%20HD/", "/" ) );
	var shapeStyle = shape.style();
	var shapeFill = shapeStyle.fill();
	
	shapeFill.setFillType( 4 );
	shapeFill.setPatternFillType( 1 );

	if ( 5 < fw2json.appVer.minor ) {
		var fillCollection = shapeFill.documentData().images();
		shapeFill.setPatternImage_collection_( filePath, fillCollection );
	} else {
		shape.style().fills().firstObject().setPatternImage( filePath );
		shape.style().fills().firstObject().setPatternFillType( 1 );
	}
}

function addGradientFill( shape, pathAttrs ) {
	var shapeStyle = shape.style();
	log( '>>> addGradientFill' );
	log( shape.frame() );
	// shapeStyle.fills().addNewStylePart();
	var shapeFill = shapeStyle.fill();
	shapeFill.setFillType( 1 ); // gradient fill
	var attrs = pathAttrs.fill.gradient;

	var gradient = shapeFill.gradient();
	switch ( attrs.gradientType ) {
		case 'linear':
			gradient.setGradientType( 0 );
			break;
		case 'radial':
			gradient.setGradientType( 1 );
			break;
		case 'conical':
			gradient.setGradientType( 2 );
			break;
		default:
			gradient.setGradientType( 0 );
			break;
	}

	var gradientNodes = attrs.nodes.concat( attrs.opacityNodes );

	// sort gradient stops by position
	for ( var i = 0; i < gradientNodes.length - 1; i++ ) {
		for ( var j = gradientNodes.length - 1; j > i; j-- ) {
			if ( gradientNodes[j - 1].position > gradientNodes[j].position ) {
				var exchenge = gradientNodes[j - 1];
				gradientNodes[j - 1] = gradientNodes[j];
				gradientNodes[j] = exchenge;
			}
		};
	};
	// log( 'gradientNodes' );
	// log( gradientNodes );

	// get gradient attributes
	var optimazedPoints = [];
	for ( var i = 0, index = 0; i < gradientNodes.length; i++ ) {
		for ( var j = i; j < gradientNodes.length; j++ ) {
			if ( !gradientNodes[i].isOpacityNode ) {
				if ( gradientNodes[j].isOpacityNode && gradientNodes[i].position <= gradientNodes[j].position ) {
					optimazedPoints[index] = {};
					optimazedPoints[index].color = gradientNodes[i].color;
					optimazedPoints[index].position = gradientNodes[i].position;
					if ( 9 == gradientNodes[j].color.length ) {
						var assets = {prev:{}, next:{}, current:{}};
						assets.prev.position    = optimazedPoints[index - 1].position;
						assets.prev.opacity     = optimazedPoints[index - 1].opacity;
						assets.next.position    = gradientNodes[j].position;
						assets.next.opacity     = getOpacityByDigit( gradientNodes[j].color.slice( 7, 9 ) );
						assets.current.position = optimazedPoints[index].position;
						optimazedPoints[index].opacity = getGradientOpacity( assets );
					} else {
						optimazedPoints[index].opacity = 1;
					}
					index++;
					break;
				}
			} else if ( 0 < i && gradientNodes[i - 1].position != gradientNodes[i].position ) {
				var gradientAssets = {prev:{}, next:{}, current:{}};

				gradientAssets.prev.color    = optimazedPoints[index - 1].color;
				gradientAssets.prev.position = optimazedPoints[index - 1].position;
				gradientAssets.next.color    = optimazedPoints[index - 1].color;
				gradientAssets.next.position = 1;

				for ( var k = j; k < gradientNodes.length; k++ ) {
					if ( !gradientNodes[k].isOpacityNode ) {
						gradientAssets.next.color    = gradientNodes[k].color;
						gradientAssets.next.position = gradientNodes[k].position;
					} 
				}

				gradientAssets.current.position = gradientNodes[i].position;

				optimazedPoints[index] = {};
				optimazedPoints[index].color = getGradientStopColorOnOpacitySide( gradientAssets );
				optimazedPoints[index].position = gradientNodes[i].position;
				if ( 9 == gradientNodes[i].color.length ) {
					optimazedPoints[index].opacity = getOpacityByDigit( gradientNodes[i].color.slice( 7, 9 ) );
				} else {
					optimazedPoints[index].opacity = 1;
				}
				index++;
				break;
			} else {
				optimazedPoints[index] = {};
				optimazedPoints[index].color = gradientNodes[j].color;
				optimazedPoints[index].position = gradientNodes[j].position;
			}
		}
	}
	// log( optimazedPoints );

	var orignPoint = optimazedPoints.length;
	for ( var i = 0; i < orignPoint; i++ ) {
		if ( 0 != optimazedPoints[i].position && 1 != optimazedPoints[i].position ) {
			gradient.addStopAtLength( floorWithDigit( optimazedPoints[i].position, 2 ) );
		}
	}
	for ( var i = 0; i < orignPoint; i++ ) {
		var gradientColor = MSColor.colorWithSVGString( optimazedPoints[i].color );
		gradientColor.alpha = optimazedPoints[i].opacity;
		gradient.setColor_atIndex_( gradientColor, i );
	}

	var shapeX = shape.frame().x();
	var shapeY = shape.frame().y();
	var shapeW = shape.frame().width();
	var shapeH = shape.frame().height();
	var startX = ( pathAttrs.fillHandle1.x - shapeX ) / shapeW;
	var startY = ( pathAttrs.fillHandle1.y - shapeY ) / shapeH;
	gradient.setPoint_atIndex_( CGPointMake( startX, startY ), 0 );
	if ( 'conical' != attrs.gradientType ) {
		var endX = ( pathAttrs.fillHandle2.x - shapeX ) / shapeW;
		var endY = ( pathAttrs.fillHandle2.y - shapeY ) / shapeH;
		gradient.setPoint_atIndex_( CGPointMake( endX, endY ), orignPoint - 1 );
	}
}

// utilities
function getCoordfromTrigFunc( radius, angle, isPsLE ) {
	var coord = {}
	if ( !isPsLE ) {
		angle = 360 - angle;
	} else {
		angle = 180 - angle;
	}

	coord.x = radius * Math.cos( angle / 180 * Math.PI );
	coord.y = radius * Math.sin( angle / 180 * Math.PI );

	return coord;
}

function getGradientStopColorOnOpacitySide ( assets ) {
	// log( assets );

	var pr = hex2Digit( assets.prev.color.slice( 1, 3 ) ) - 0;
	var pg = hex2Digit( assets.prev.color.slice( 3, 5 ) ) - 0;
	var pb = hex2Digit( assets.prev.color.slice( 5, 7 ) ) - 0;

	var nr = hex2Digit( assets.next.color.slice( 1, 3 ) ) - 0;
	var ng = hex2Digit( assets.next.color.slice( 3, 5 ) ) - 0;
	var nb = hex2Digit( assets.next.color.slice( 5, 7 ) ) - 0;

	// log( '    prevColor: ' + pr + ' / ' + pg + ' / ' + pb + ' | nextColor: ' + nr + ' / ' + ng + ' / ' + nb );

	var range = assets.next.position - assets.prev.position;
	var offset = 1 / range;
	// log( '    offset: ' + offset );
	var localRangePosition = ( assets.current.position - assets.prev.position ) * offset;
	// log( '    range: ' + range + ' / offset: ' + offset + ' / localRangePosition: ' + localRangePosition );
	
	var r = floorWithDigit( pr + ( nr - pr ) * localRangePosition, 0 );
	var g = floorWithDigit( pg + ( ng - pg ) * localRangePosition, 0 );
	var b = floorWithDigit( pb + ( nb - pb ) * localRangePosition, 0 );

	r = digit2Hex( r );
	g = digit2Hex( g );
	b = digit2Hex( b );
	// log( '    retrun: ' + '#' + r + g + b );

	return '#' + r + g + b;
}

function getGradientOpacity ( assets ) {

	var range = assets.next.position - assets.prev.position;
	var offset = 1 / range;
	var localRangePosition = ( assets.current.position - assets.prev.position ) * offset;

	var opacity = floorWithDigit( assets.prev.opacity + ( assets.next.opacity - assets.prev.opacity ) * localRangePosition, 2 );

	return opacity;
}

function floorWithDigit ( _val, _specifiedDigit ) {
	var digit = Math.pow( 10, _specifiedDigit );
	var val = Math.floor( _val * digit );

	return  val / digit;
}

function getOpacityByDigit ( _hex ) {
	var digit = ( parseInt( '0x' + _hex ).toString( 10 ) ) / 255;

	return floorWithDigit( digit, 2 );
}

function digit2Hex ( _digit ) {
	var hex = parseInt( _digit ).toString( 16 );
	if ( 1 == hex.length ) hex = '0' + hex;
	return hex;
}

function hex2Digit ( _hex ) {
	return ( parseInt( '0x' + _hex ).toString( 10 ) );
}

function bit2Percent ( val ) {
	return floorWithDigit( val / 255, 4 );
}

function getHexColor( color ) {
	if( 7 == color.length ) return color;
	return color.slice( 0, 7 );
}

function getOpacity( color ) {
	if( 7 == color.length ) return 1;

	var hex = color.slice( 7, 9 );
	var opacity = parseInt( '0x' + hex ).toString( 10 ) / 255;
	opacity = floorWithDigit( opacity, 2 );

	return opacity;
}

function hexToColor ( hex ) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex),
        red = parseInt(result[1], 16) / 255,
        green = parseInt(result[2], 16) / 255,
        blue = parseInt(result[3], 16) / 255,
        alpha = getOpacity( hex );
    return NSColor.colorWithCalibratedRed_green_blue_alpha( red, green, blue, alpha )
}